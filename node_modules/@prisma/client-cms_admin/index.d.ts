
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Audits
 * @schema.display_name 审计日志
 */
export type Audits = {
  id: number
  createdAt: Date
  /**
   * @schema.title 关联 id
   */
  auditId: number
  /**
   * @schema.title 审计类型(关联 schema)
   */
  auditType: string
  /**
   * @schema.title 用户 id
   */
  userId: string
  /**
   * @schema.title 用户名
   */
  username: string | null
  /**
   * @schema.title 动作(e.g. update)
   */
  action: string
  /**
   * @schema.title 变化
   */
  auditChanges: string
  /**
   * @schema.title 版本
   */
  version: number
}

/**
 * Model SiteTemplate
 * @schema.display_name 网站模板
 * @schema.display_column name
 */
export type SiteTemplate = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 模板名称
   */
  name: string
  /**
   * @schema.title 模板内容
   * @schema.column_type textarea
   */
  template: string
}

/**
 * Model SiteTemplateDataDef
 * @schema.display_name 模板数据定义
 * @schema.display_column siteTemplateId
 */
export type SiteTemplateDataDef = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.reference SiteTemplate
   * @schema.x-unique true
   */
  siteTemplateId: number
  /**
   * @schema.title 结构定义
   */
  defData: Prisma.JsonValue
}

/**
 * Model Customer
 * @schema.primary_key id
 * @schema.display_name 客户信息
 * @schema.display_column name
 * @schema.display_primary_key false
 * @schema.searchable_columns name
 */
export type Customer = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 客户名称
   */
  name: string
  /**
   * @schema.title 客户扩展数据
   */
  extendData: Prisma.JsonValue | null
}

/**
 * Model Site
 * @schema.primary_key id
 * @schema.display_name 网站
 * @schema.display_column name
 * @schema.display_primary_key false
 * @schema.searchable_columns name
 */
export type Site = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 网站名称
   */
  name: string
  /**
   * @schema.title COS 地址
   */
  cosUrl: string
  /**
   * @schema.reference SiteTemplate
   */
  siteTemplateId: number
  /**
   * @schema.reference Customer
   */
  customerId: number
  /**
   * @schema.title Slot 数据
   */
  slotData: Prisma.JsonValue
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string | null
  email: string | null
  emailVerified: Date | null
  image: string | null
  createdAt: Date
}

/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  userId: string
  type: string
  provider: string
  providerAccountId: string
  refresh_token: string | null
  refresh_token_expires_in: number | null
  access_token: string | null
  expires_at: number | null
  token_type: string | null
  scope: string | null
  id_token: string | null
  session_state: string | null
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: string
  sessionToken: string
  userId: string
  expires: Date
}

/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = {
  identifier: string
  token: string
  expires: Date
}

/**
 * Model Project
 * 
 */
export type Project = {
  id: string
  name: string
  slug: string
  logo: string | null
  password: string | null
  type: string
  usage: number
  usageLimit: number
  plan: string
  stripeId: string | null
  billingCycleStart: number | null
  region: string | null
  endpoint: string | null
  bucket: string | null
  useHost: string | null
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
}

/**
 * Model ProjectInvite
 * 
 */
export type ProjectInvite = {
  email: string
  expires: Date
  projectId: string
  createdAt: Date
}

/**
 * Model ProjectUsers
 * 
 */
export type ProjectUsers = {
  id: string
  role: Role
  createdAt: Date
  updatedAt: Date
  userId: string
  projectId: string
}

/**
 * Model SentEmail
 * 
 */
export type SentEmail = {
  id: string
  type: EmailType
  createdAt: Date
  projectId: string | null
}

/**
 * Model Domain
 * 
 */
export type Domain = {
  id: string
  slug: string
  verified: boolean
  target: string | null
  type: string
  description: string | null
  projectId: string | null
  primary: boolean
  lastChecked: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Link
 * 
 */
export type Link = {
  id: string
  domain: string
  key: string
  url: string
  archived: boolean
  expiresAt: Date | null
  password: string | null
  proxy: boolean
  title: string | null
  description: string | null
  image: string | null
  utm_source: string | null
  utm_medium: string | null
  utm_campaign: string | null
  utm_term: string | null
  utm_content: string | null
  rewrite: boolean
  ios: string | null
  android: string | null
  userId: string | null
  projectId: string | null
  clicks: number
  publicStats: boolean
  createdAt: Date
  updatedAt: Date
  tagId: string | null
}

/**
 * Model Tag
 * 
 */
export type Tag = {
  id: string
  name: string
  color: string
  createdAt: Date
  updatedAt: Date
  projectId: string
}

/**
 * Model jackson_index
 * 
 */
export type jackson_index = {
  id: number
  key: string
  storeKey: string
}

/**
 * Model jackson_store
 * 
 */
export type jackson_store = {
  key: string
  value: string
  iv: string | null
  tag: string | null
  createdAt: Date
  modifiedAt: Date | null
}

/**
 * Model jackson_ttl
 * 
 */
export type jackson_ttl = {
  key: string
  expiresAt: bigint
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const EmailType: {
  firstDomainInvalidEmail: 'firstDomainInvalidEmail',
  secondDomainInvalidEmail: 'secondDomainInvalidEmail',
  firstUsageLimitEmail: 'firstUsageLimitEmail',
  secondUsageLimitEmail: 'secondUsageLimitEmail'
};

export type EmailType = (typeof EmailType)[keyof typeof EmailType]


export const Role: {
  owner: 'owner',
  member: 'member'
};

export type Role = (typeof Role)[keyof typeof Role]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Audits
 * const audits = await prisma.audits.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Audits
   * const audits = await prisma.audits.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.audits`: Exposes CRUD operations for the **Audits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audits
    * const audits = await prisma.audits.findMany()
    * ```
    */
  get audits(): Prisma.AuditsDelegate<GlobalReject>;

  /**
   * `prisma.siteTemplate`: Exposes CRUD operations for the **SiteTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteTemplates
    * const siteTemplates = await prisma.siteTemplate.findMany()
    * ```
    */
  get siteTemplate(): Prisma.SiteTemplateDelegate<GlobalReject>;

  /**
   * `prisma.siteTemplateDataDef`: Exposes CRUD operations for the **SiteTemplateDataDef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteTemplateDataDefs
    * const siteTemplateDataDefs = await prisma.siteTemplateDataDef.findMany()
    * ```
    */
  get siteTemplateDataDef(): Prisma.SiteTemplateDataDefDelegate<GlobalReject>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject>;

  /**
   * `prisma.site`: Exposes CRUD operations for the **Site** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sites
    * const sites = await prisma.site.findMany()
    * ```
    */
  get site(): Prisma.SiteDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<GlobalReject>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<GlobalReject>;

  /**
   * `prisma.projectInvite`: Exposes CRUD operations for the **ProjectInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectInvites
    * const projectInvites = await prisma.projectInvite.findMany()
    * ```
    */
  get projectInvite(): Prisma.ProjectInviteDelegate<GlobalReject>;

  /**
   * `prisma.projectUsers`: Exposes CRUD operations for the **ProjectUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectUsers
    * const projectUsers = await prisma.projectUsers.findMany()
    * ```
    */
  get projectUsers(): Prisma.ProjectUsersDelegate<GlobalReject>;

  /**
   * `prisma.sentEmail`: Exposes CRUD operations for the **SentEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SentEmails
    * const sentEmails = await prisma.sentEmail.findMany()
    * ```
    */
  get sentEmail(): Prisma.SentEmailDelegate<GlobalReject>;

  /**
   * `prisma.domain`: Exposes CRUD operations for the **Domain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domains
    * const domains = await prisma.domain.findMany()
    * ```
    */
  get domain(): Prisma.DomainDelegate<GlobalReject>;

  /**
   * `prisma.link`: Exposes CRUD operations for the **Link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Links
    * const links = await prisma.link.findMany()
    * ```
    */
  get link(): Prisma.LinkDelegate<GlobalReject>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<GlobalReject>;

  /**
   * `prisma.jackson_index`: Exposes CRUD operations for the **jackson_index** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jackson_indices
    * const jackson_indices = await prisma.jackson_index.findMany()
    * ```
    */
  get jackson_index(): Prisma.jackson_indexDelegate<GlobalReject>;

  /**
   * `prisma.jackson_store`: Exposes CRUD operations for the **jackson_store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jackson_stores
    * const jackson_stores = await prisma.jackson_store.findMany()
    * ```
    */
  get jackson_store(): Prisma.jackson_storeDelegate<GlobalReject>;

  /**
   * `prisma.jackson_ttl`: Exposes CRUD operations for the **jackson_ttl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jackson_ttls
    * const jackson_ttls = await prisma.jackson_ttl.findMany()
    * ```
    */
  get jackson_ttl(): Prisma.jackson_ttlDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.0
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Audits: 'Audits',
    SiteTemplate: 'SiteTemplate',
    SiteTemplateDataDef: 'SiteTemplateDataDef',
    Customer: 'Customer',
    Site: 'Site',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Project: 'Project',
    ProjectInvite: 'ProjectInvite',
    ProjectUsers: 'ProjectUsers',
    SentEmail: 'SentEmail',
    Domain: 'Domain',
    Link: 'Link',
    Tag: 'Tag',
    jackson_index: 'jackson_index',
    jackson_store: 'jackson_store',
    jackson_ttl: 'jackson_ttl'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SiteTemplateCountOutputType
   */


  export type SiteTemplateCountOutputType = {
    site: number
  }

  export type SiteTemplateCountOutputTypeSelect = {
    site?: boolean
  }

  export type SiteTemplateCountOutputTypeGetPayload<S extends boolean | null | undefined | SiteTemplateCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SiteTemplateCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SiteTemplateCountOutputTypeArgs)
    ? SiteTemplateCountOutputType 
    : S extends { select: any } & (SiteTemplateCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SiteTemplateCountOutputType ? SiteTemplateCountOutputType[P] : never
  } 
      : SiteTemplateCountOutputType




  // Custom InputTypes

  /**
   * SiteTemplateCountOutputType without action
   */
  export type SiteTemplateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateCountOutputType
     */
    select?: SiteTemplateCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomerCountOutputType
   */


  export type CustomerCountOutputType = {
    site: number
  }

  export type CustomerCountOutputTypeSelect = {
    site?: boolean
  }

  export type CustomerCountOutputTypeGetPayload<S extends boolean | null | undefined | CustomerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustomerCountOutputTypeArgs)
    ? CustomerCountOutputType 
    : S extends { select: any } & (CustomerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustomerCountOutputType ? CustomerCountOutputType[P] : never
  } 
      : CustomerCountOutputType




  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    accounts: number
    sessions: number
    projects: number
    links: number
  }

  export type UserCountOutputTypeSelect = {
    accounts?: boolean
    sessions?: boolean
    projects?: boolean
    links?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ProjectCountOutputType
   */


  export type ProjectCountOutputType = {
    users: number
    invites: number
    sentEmails: number
    domains: number
    links: number
    tags: number
  }

  export type ProjectCountOutputTypeSelect = {
    users?: boolean
    invites?: boolean
    sentEmails?: boolean
    domains?: boolean
    links?: boolean
    tags?: boolean
  }

  export type ProjectCountOutputTypeGetPayload<S extends boolean | null | undefined | ProjectCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProjectCountOutputTypeArgs)
    ? ProjectCountOutputType 
    : S extends { select: any } & (ProjectCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProjectCountOutputType ? ProjectCountOutputType[P] : never
  } 
      : ProjectCountOutputType




  // Custom InputTypes

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect | null
  }



  /**
   * Count Type DomainCountOutputType
   */


  export type DomainCountOutputType = {
    links: number
  }

  export type DomainCountOutputTypeSelect = {
    links?: boolean
  }

  export type DomainCountOutputTypeGetPayload<S extends boolean | null | undefined | DomainCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DomainCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DomainCountOutputTypeArgs)
    ? DomainCountOutputType 
    : S extends { select: any } & (DomainCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DomainCountOutputType ? DomainCountOutputType[P] : never
  } 
      : DomainCountOutputType




  // Custom InputTypes

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DomainCountOutputType
     */
    select?: DomainCountOutputTypeSelect | null
  }



  /**
   * Count Type TagCountOutputType
   */


  export type TagCountOutputType = {
    links: number
  }

  export type TagCountOutputTypeSelect = {
    links?: boolean
  }

  export type TagCountOutputTypeGetPayload<S extends boolean | null | undefined | TagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TagCountOutputTypeArgs)
    ? TagCountOutputType 
    : S extends { select: any } & (TagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TagCountOutputType ? TagCountOutputType[P] : never
  } 
      : TagCountOutputType




  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Audits
   */


  export type AggregateAudits = {
    _count: AuditsCountAggregateOutputType | null
    _avg: AuditsAvgAggregateOutputType | null
    _sum: AuditsSumAggregateOutputType | null
    _min: AuditsMinAggregateOutputType | null
    _max: AuditsMaxAggregateOutputType | null
  }

  export type AuditsAvgAggregateOutputType = {
    id: number | null
    auditId: number | null
    version: number | null
  }

  export type AuditsSumAggregateOutputType = {
    id: number | null
    auditId: number | null
    version: number | null
  }

  export type AuditsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    auditId: number | null
    auditType: string | null
    userId: string | null
    username: string | null
    action: string | null
    auditChanges: string | null
    version: number | null
  }

  export type AuditsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    auditId: number | null
    auditType: string | null
    userId: string | null
    username: string | null
    action: string | null
    auditChanges: string | null
    version: number | null
  }

  export type AuditsCountAggregateOutputType = {
    id: number
    createdAt: number
    auditId: number
    auditType: number
    userId: number
    username: number
    action: number
    auditChanges: number
    version: number
    _all: number
  }


  export type AuditsAvgAggregateInputType = {
    id?: true
    auditId?: true
    version?: true
  }

  export type AuditsSumAggregateInputType = {
    id?: true
    auditId?: true
    version?: true
  }

  export type AuditsMinAggregateInputType = {
    id?: true
    createdAt?: true
    auditId?: true
    auditType?: true
    userId?: true
    username?: true
    action?: true
    auditChanges?: true
    version?: true
  }

  export type AuditsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    auditId?: true
    auditType?: true
    userId?: true
    username?: true
    action?: true
    auditChanges?: true
    version?: true
  }

  export type AuditsCountAggregateInputType = {
    id?: true
    createdAt?: true
    auditId?: true
    auditType?: true
    userId?: true
    username?: true
    action?: true
    auditChanges?: true
    version?: true
    _all?: true
  }

  export type AuditsAggregateArgs = {
    /**
     * Filter which Audits to aggregate.
     */
    where?: AuditsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: Enumerable<AuditsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Audits
    **/
    _count?: true | AuditsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditsMaxAggregateInputType
  }

  export type GetAuditsAggregateType<T extends AuditsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudits[P]>
      : GetScalarType<T[P], AggregateAudits[P]>
  }




  export type AuditsGroupByArgs = {
    where?: AuditsWhereInput
    orderBy?: Enumerable<AuditsOrderByWithAggregationInput>
    by: AuditsScalarFieldEnum[]
    having?: AuditsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditsCountAggregateInputType | true
    _avg?: AuditsAvgAggregateInputType
    _sum?: AuditsSumAggregateInputType
    _min?: AuditsMinAggregateInputType
    _max?: AuditsMaxAggregateInputType
  }


  export type AuditsGroupByOutputType = {
    id: number
    createdAt: Date
    auditId: number
    auditType: string
    userId: string
    username: string | null
    action: string
    auditChanges: string
    version: number
    _count: AuditsCountAggregateOutputType | null
    _avg: AuditsAvgAggregateOutputType | null
    _sum: AuditsSumAggregateOutputType | null
    _min: AuditsMinAggregateOutputType | null
    _max: AuditsMaxAggregateOutputType | null
  }

  type GetAuditsGroupByPayload<T extends AuditsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuditsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditsGroupByOutputType[P]>
            : GetScalarType<T[P], AuditsGroupByOutputType[P]>
        }
      >
    >


  export type AuditsSelect = {
    id?: boolean
    createdAt?: boolean
    auditId?: boolean
    auditType?: boolean
    userId?: boolean
    username?: boolean
    action?: boolean
    auditChanges?: boolean
    version?: boolean
  }


  export type AuditsGetPayload<S extends boolean | null | undefined | AuditsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Audits :
    S extends undefined ? never :
    S extends { include: any } & (AuditsArgs | AuditsFindManyArgs)
    ? Audits 
    : S extends { select: any } & (AuditsArgs | AuditsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Audits ? Audits[P] : never
  } 
      : Audits


  type AuditsCountArgs = 
    Omit<AuditsFindManyArgs, 'select' | 'include'> & {
      select?: AuditsCountAggregateInputType | true
    }

  export interface AuditsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Audits that matches the filter.
     * @param {AuditsFindUniqueArgs} args - Arguments to find a Audits
     * @example
     * // Get one Audits
     * const audits = await prisma.audits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuditsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Audits'> extends True ? Prisma__AuditsClient<AuditsGetPayload<T>> : Prisma__AuditsClient<AuditsGetPayload<T> | null, null>

    /**
     * Find one Audits that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuditsFindUniqueOrThrowArgs} args - Arguments to find a Audits
     * @example
     * // Get one Audits
     * const audits = await prisma.audits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuditsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AuditsFindUniqueOrThrowArgs>
    ): Prisma__AuditsClient<AuditsGetPayload<T>>

    /**
     * Find the first Audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditsFindFirstArgs} args - Arguments to find a Audits
     * @example
     * // Get one Audits
     * const audits = await prisma.audits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuditsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Audits'> extends True ? Prisma__AuditsClient<AuditsGetPayload<T>> : Prisma__AuditsClient<AuditsGetPayload<T> | null, null>

    /**
     * Find the first Audits that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditsFindFirstOrThrowArgs} args - Arguments to find a Audits
     * @example
     * // Get one Audits
     * const audits = await prisma.audits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuditsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditsFindFirstOrThrowArgs>
    ): Prisma__AuditsClient<AuditsGetPayload<T>>

    /**
     * Find zero or more Audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audits
     * const audits = await prisma.audits.findMany()
     * 
     * // Get first 10 Audits
     * const audits = await prisma.audits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditsWithIdOnly = await prisma.audits.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuditsFindManyArgs>(
      args?: SelectSubset<T, AuditsFindManyArgs>
    ): Prisma.PrismaPromise<Array<AuditsGetPayload<T>>>

    /**
     * Create a Audits.
     * @param {AuditsCreateArgs} args - Arguments to create a Audits.
     * @example
     * // Create one Audits
     * const Audits = await prisma.audits.create({
     *   data: {
     *     // ... data to create a Audits
     *   }
     * })
     * 
    **/
    create<T extends AuditsCreateArgs>(
      args: SelectSubset<T, AuditsCreateArgs>
    ): Prisma__AuditsClient<AuditsGetPayload<T>>

    /**
     * Create many Audits.
     *     @param {AuditsCreateManyArgs} args - Arguments to create many Audits.
     *     @example
     *     // Create many Audits
     *     const audits = await prisma.audits.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuditsCreateManyArgs>(
      args?: SelectSubset<T, AuditsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Audits.
     * @param {AuditsDeleteArgs} args - Arguments to delete one Audits.
     * @example
     * // Delete one Audits
     * const Audits = await prisma.audits.delete({
     *   where: {
     *     // ... filter to delete one Audits
     *   }
     * })
     * 
    **/
    delete<T extends AuditsDeleteArgs>(
      args: SelectSubset<T, AuditsDeleteArgs>
    ): Prisma__AuditsClient<AuditsGetPayload<T>>

    /**
     * Update one Audits.
     * @param {AuditsUpdateArgs} args - Arguments to update one Audits.
     * @example
     * // Update one Audits
     * const audits = await prisma.audits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditsUpdateArgs>(
      args: SelectSubset<T, AuditsUpdateArgs>
    ): Prisma__AuditsClient<AuditsGetPayload<T>>

    /**
     * Delete zero or more Audits.
     * @param {AuditsDeleteManyArgs} args - Arguments to filter Audits to delete.
     * @example
     * // Delete a few Audits
     * const { count } = await prisma.audits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditsDeleteManyArgs>(
      args?: SelectSubset<T, AuditsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audits
     * const audits = await prisma.audits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditsUpdateManyArgs>(
      args: SelectSubset<T, AuditsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audits.
     * @param {AuditsUpsertArgs} args - Arguments to update or create a Audits.
     * @example
     * // Update or create a Audits
     * const audits = await prisma.audits.upsert({
     *   create: {
     *     // ... data to create a Audits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audits we want to update
     *   }
     * })
    **/
    upsert<T extends AuditsUpsertArgs>(
      args: SelectSubset<T, AuditsUpsertArgs>
    ): Prisma__AuditsClient<AuditsGetPayload<T>>

    /**
     * Count the number of Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditsCountArgs} args - Arguments to filter Audits to count.
     * @example
     * // Count the number of Audits
     * const count = await prisma.audits.count({
     *   where: {
     *     // ... the filter for the Audits we want to count
     *   }
     * })
    **/
    count<T extends AuditsCountArgs>(
      args?: Subset<T, AuditsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditsAggregateArgs>(args: Subset<T, AuditsAggregateArgs>): Prisma.PrismaPromise<GetAuditsAggregateType<T>>

    /**
     * Group by Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditsGroupByArgs['orderBy'] }
        : { orderBy?: AuditsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Audits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuditsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Audits base type for findUnique actions
   */
  export type AuditsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * Filter, which Audits to fetch.
     */
    where: AuditsWhereUniqueInput
  }

  /**
   * Audits findUnique
   */
  export interface AuditsFindUniqueArgs extends AuditsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Audits findUniqueOrThrow
   */
  export type AuditsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * Filter, which Audits to fetch.
     */
    where: AuditsWhereUniqueInput
  }


  /**
   * Audits base type for findFirst actions
   */
  export type AuditsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * Filter, which Audits to fetch.
     */
    where?: AuditsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: Enumerable<AuditsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: Enumerable<AuditsScalarFieldEnum>
  }

  /**
   * Audits findFirst
   */
  export interface AuditsFindFirstArgs extends AuditsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Audits findFirstOrThrow
   */
  export type AuditsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * Filter, which Audits to fetch.
     */
    where?: AuditsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: Enumerable<AuditsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: Enumerable<AuditsScalarFieldEnum>
  }


  /**
   * Audits findMany
   */
  export type AuditsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * Filter, which Audits to fetch.
     */
    where?: AuditsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: Enumerable<AuditsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Audits.
     */
    cursor?: AuditsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    distinct?: Enumerable<AuditsScalarFieldEnum>
  }


  /**
   * Audits create
   */
  export type AuditsCreateArgs = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * The data needed to create a Audits.
     */
    data: XOR<AuditsCreateInput, AuditsUncheckedCreateInput>
  }


  /**
   * Audits createMany
   */
  export type AuditsCreateManyArgs = {
    /**
     * The data used to create many Audits.
     */
    data: Enumerable<AuditsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Audits update
   */
  export type AuditsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * The data needed to update a Audits.
     */
    data: XOR<AuditsUpdateInput, AuditsUncheckedUpdateInput>
    /**
     * Choose, which Audits to update.
     */
    where: AuditsWhereUniqueInput
  }


  /**
   * Audits updateMany
   */
  export type AuditsUpdateManyArgs = {
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditsUpdateManyMutationInput, AuditsUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditsWhereInput
  }


  /**
   * Audits upsert
   */
  export type AuditsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * The filter to search for the Audits to update in case it exists.
     */
    where: AuditsWhereUniqueInput
    /**
     * In case the Audits found by the `where` argument doesn't exist, create a new Audits with this data.
     */
    create: XOR<AuditsCreateInput, AuditsUncheckedCreateInput>
    /**
     * In case the Audits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditsUpdateInput, AuditsUncheckedUpdateInput>
  }


  /**
   * Audits delete
   */
  export type AuditsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
    /**
     * Filter which Audits to delete.
     */
    where: AuditsWhereUniqueInput
  }


  /**
   * Audits deleteMany
   */
  export type AuditsDeleteManyArgs = {
    /**
     * Filter which Audits to delete
     */
    where?: AuditsWhereInput
  }


  /**
   * Audits without action
   */
  export type AuditsArgs = {
    /**
     * Select specific fields to fetch from the Audits
     */
    select?: AuditsSelect | null
  }



  /**
   * Model SiteTemplate
   */


  export type AggregateSiteTemplate = {
    _count: SiteTemplateCountAggregateOutputType | null
    _avg: SiteTemplateAvgAggregateOutputType | null
    _sum: SiteTemplateSumAggregateOutputType | null
    _min: SiteTemplateMinAggregateOutputType | null
    _max: SiteTemplateMaxAggregateOutputType | null
  }

  export type SiteTemplateAvgAggregateOutputType = {
    id: number | null
  }

  export type SiteTemplateSumAggregateOutputType = {
    id: number | null
  }

  export type SiteTemplateMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    template: string | null
  }

  export type SiteTemplateMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    template: string | null
  }

  export type SiteTemplateCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    template: number
    _all: number
  }


  export type SiteTemplateAvgAggregateInputType = {
    id?: true
  }

  export type SiteTemplateSumAggregateInputType = {
    id?: true
  }

  export type SiteTemplateMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    template?: true
  }

  export type SiteTemplateMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    template?: true
  }

  export type SiteTemplateCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    template?: true
    _all?: true
  }

  export type SiteTemplateAggregateArgs = {
    /**
     * Filter which SiteTemplate to aggregate.
     */
    where?: SiteTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTemplates to fetch.
     */
    orderBy?: Enumerable<SiteTemplateOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteTemplates
    **/
    _count?: true | SiteTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteTemplateMaxAggregateInputType
  }

  export type GetSiteTemplateAggregateType<T extends SiteTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteTemplate[P]>
      : GetScalarType<T[P], AggregateSiteTemplate[P]>
  }




  export type SiteTemplateGroupByArgs = {
    where?: SiteTemplateWhereInput
    orderBy?: Enumerable<SiteTemplateOrderByWithAggregationInput>
    by: SiteTemplateScalarFieldEnum[]
    having?: SiteTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteTemplateCountAggregateInputType | true
    _avg?: SiteTemplateAvgAggregateInputType
    _sum?: SiteTemplateSumAggregateInputType
    _min?: SiteTemplateMinAggregateInputType
    _max?: SiteTemplateMaxAggregateInputType
  }


  export type SiteTemplateGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    template: string
    _count: SiteTemplateCountAggregateOutputType | null
    _avg: SiteTemplateAvgAggregateOutputType | null
    _sum: SiteTemplateSumAggregateOutputType | null
    _min: SiteTemplateMinAggregateOutputType | null
    _max: SiteTemplateMaxAggregateOutputType | null
  }

  type GetSiteTemplateGroupByPayload<T extends SiteTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SiteTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], SiteTemplateGroupByOutputType[P]>
        }
      >
    >


  export type SiteTemplateSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    template?: boolean
    site?: boolean | SiteTemplate$siteArgs
    siteTemplateDataDef?: boolean | SiteTemplateDataDefArgs
    _count?: boolean | SiteTemplateCountOutputTypeArgs
  }


  export type SiteTemplateInclude = {
    site?: boolean | SiteTemplate$siteArgs
    siteTemplateDataDef?: boolean | SiteTemplateDataDefArgs
    _count?: boolean | SiteTemplateCountOutputTypeArgs
  }

  export type SiteTemplateGetPayload<S extends boolean | null | undefined | SiteTemplateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SiteTemplate :
    S extends undefined ? never :
    S extends { include: any } & (SiteTemplateArgs | SiteTemplateFindManyArgs)
    ? SiteTemplate  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'site' ? Array < SiteGetPayload<S['include'][P]>>  :
        P extends 'siteTemplateDataDef' ? SiteTemplateDataDefGetPayload<S['include'][P]> | null :
        P extends '_count' ? SiteTemplateCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SiteTemplateArgs | SiteTemplateFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'site' ? Array < SiteGetPayload<S['select'][P]>>  :
        P extends 'siteTemplateDataDef' ? SiteTemplateDataDefGetPayload<S['select'][P]> | null :
        P extends '_count' ? SiteTemplateCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SiteTemplate ? SiteTemplate[P] : never
  } 
      : SiteTemplate


  type SiteTemplateCountArgs = 
    Omit<SiteTemplateFindManyArgs, 'select' | 'include'> & {
      select?: SiteTemplateCountAggregateInputType | true
    }

  export interface SiteTemplateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SiteTemplate that matches the filter.
     * @param {SiteTemplateFindUniqueArgs} args - Arguments to find a SiteTemplate
     * @example
     * // Get one SiteTemplate
     * const siteTemplate = await prisma.siteTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SiteTemplateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SiteTemplateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SiteTemplate'> extends True ? Prisma__SiteTemplateClient<SiteTemplateGetPayload<T>> : Prisma__SiteTemplateClient<SiteTemplateGetPayload<T> | null, null>

    /**
     * Find one SiteTemplate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SiteTemplateFindUniqueOrThrowArgs} args - Arguments to find a SiteTemplate
     * @example
     * // Get one SiteTemplate
     * const siteTemplate = await prisma.siteTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SiteTemplateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SiteTemplateFindUniqueOrThrowArgs>
    ): Prisma__SiteTemplateClient<SiteTemplateGetPayload<T>>

    /**
     * Find the first SiteTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateFindFirstArgs} args - Arguments to find a SiteTemplate
     * @example
     * // Get one SiteTemplate
     * const siteTemplate = await prisma.siteTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SiteTemplateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SiteTemplateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SiteTemplate'> extends True ? Prisma__SiteTemplateClient<SiteTemplateGetPayload<T>> : Prisma__SiteTemplateClient<SiteTemplateGetPayload<T> | null, null>

    /**
     * Find the first SiteTemplate that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateFindFirstOrThrowArgs} args - Arguments to find a SiteTemplate
     * @example
     * // Get one SiteTemplate
     * const siteTemplate = await prisma.siteTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SiteTemplateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SiteTemplateFindFirstOrThrowArgs>
    ): Prisma__SiteTemplateClient<SiteTemplateGetPayload<T>>

    /**
     * Find zero or more SiteTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteTemplates
     * const siteTemplates = await prisma.siteTemplate.findMany()
     * 
     * // Get first 10 SiteTemplates
     * const siteTemplates = await prisma.siteTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteTemplateWithIdOnly = await prisma.siteTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SiteTemplateFindManyArgs>(
      args?: SelectSubset<T, SiteTemplateFindManyArgs>
    ): Prisma.PrismaPromise<Array<SiteTemplateGetPayload<T>>>

    /**
     * Create a SiteTemplate.
     * @param {SiteTemplateCreateArgs} args - Arguments to create a SiteTemplate.
     * @example
     * // Create one SiteTemplate
     * const SiteTemplate = await prisma.siteTemplate.create({
     *   data: {
     *     // ... data to create a SiteTemplate
     *   }
     * })
     * 
    **/
    create<T extends SiteTemplateCreateArgs>(
      args: SelectSubset<T, SiteTemplateCreateArgs>
    ): Prisma__SiteTemplateClient<SiteTemplateGetPayload<T>>

    /**
     * Create many SiteTemplates.
     *     @param {SiteTemplateCreateManyArgs} args - Arguments to create many SiteTemplates.
     *     @example
     *     // Create many SiteTemplates
     *     const siteTemplate = await prisma.siteTemplate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SiteTemplateCreateManyArgs>(
      args?: SelectSubset<T, SiteTemplateCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SiteTemplate.
     * @param {SiteTemplateDeleteArgs} args - Arguments to delete one SiteTemplate.
     * @example
     * // Delete one SiteTemplate
     * const SiteTemplate = await prisma.siteTemplate.delete({
     *   where: {
     *     // ... filter to delete one SiteTemplate
     *   }
     * })
     * 
    **/
    delete<T extends SiteTemplateDeleteArgs>(
      args: SelectSubset<T, SiteTemplateDeleteArgs>
    ): Prisma__SiteTemplateClient<SiteTemplateGetPayload<T>>

    /**
     * Update one SiteTemplate.
     * @param {SiteTemplateUpdateArgs} args - Arguments to update one SiteTemplate.
     * @example
     * // Update one SiteTemplate
     * const siteTemplate = await prisma.siteTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SiteTemplateUpdateArgs>(
      args: SelectSubset<T, SiteTemplateUpdateArgs>
    ): Prisma__SiteTemplateClient<SiteTemplateGetPayload<T>>

    /**
     * Delete zero or more SiteTemplates.
     * @param {SiteTemplateDeleteManyArgs} args - Arguments to filter SiteTemplates to delete.
     * @example
     * // Delete a few SiteTemplates
     * const { count } = await prisma.siteTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SiteTemplateDeleteManyArgs>(
      args?: SelectSubset<T, SiteTemplateDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteTemplates
     * const siteTemplate = await prisma.siteTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SiteTemplateUpdateManyArgs>(
      args: SelectSubset<T, SiteTemplateUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SiteTemplate.
     * @param {SiteTemplateUpsertArgs} args - Arguments to update or create a SiteTemplate.
     * @example
     * // Update or create a SiteTemplate
     * const siteTemplate = await prisma.siteTemplate.upsert({
     *   create: {
     *     // ... data to create a SiteTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends SiteTemplateUpsertArgs>(
      args: SelectSubset<T, SiteTemplateUpsertArgs>
    ): Prisma__SiteTemplateClient<SiteTemplateGetPayload<T>>

    /**
     * Count the number of SiteTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateCountArgs} args - Arguments to filter SiteTemplates to count.
     * @example
     * // Count the number of SiteTemplates
     * const count = await prisma.siteTemplate.count({
     *   where: {
     *     // ... the filter for the SiteTemplates we want to count
     *   }
     * })
    **/
    count<T extends SiteTemplateCountArgs>(
      args?: Subset<T, SiteTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteTemplateAggregateArgs>(args: Subset<T, SiteTemplateAggregateArgs>): Prisma.PrismaPromise<GetSiteTemplateAggregateType<T>>

    /**
     * Group by SiteTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteTemplateGroupByArgs['orderBy'] }
        : { orderBy?: SiteTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SiteTemplateClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    site<T extends SiteTemplate$siteArgs= {}>(args?: Subset<T, SiteTemplate$siteArgs>): Prisma.PrismaPromise<Array<SiteGetPayload<T>>| Null>;

    siteTemplateDataDef<T extends SiteTemplateDataDefArgs= {}>(args?: Subset<T, SiteTemplateDataDefArgs>): Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SiteTemplate base type for findUnique actions
   */
  export type SiteTemplateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * Filter, which SiteTemplate to fetch.
     */
    where: SiteTemplateWhereUniqueInput
  }

  /**
   * SiteTemplate findUnique
   */
  export interface SiteTemplateFindUniqueArgs extends SiteTemplateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SiteTemplate findUniqueOrThrow
   */
  export type SiteTemplateFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * Filter, which SiteTemplate to fetch.
     */
    where: SiteTemplateWhereUniqueInput
  }


  /**
   * SiteTemplate base type for findFirst actions
   */
  export type SiteTemplateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * Filter, which SiteTemplate to fetch.
     */
    where?: SiteTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTemplates to fetch.
     */
    orderBy?: Enumerable<SiteTemplateOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteTemplates.
     */
    cursor?: SiteTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteTemplates.
     */
    distinct?: Enumerable<SiteTemplateScalarFieldEnum>
  }

  /**
   * SiteTemplate findFirst
   */
  export interface SiteTemplateFindFirstArgs extends SiteTemplateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SiteTemplate findFirstOrThrow
   */
  export type SiteTemplateFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * Filter, which SiteTemplate to fetch.
     */
    where?: SiteTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTemplates to fetch.
     */
    orderBy?: Enumerable<SiteTemplateOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteTemplates.
     */
    cursor?: SiteTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteTemplates.
     */
    distinct?: Enumerable<SiteTemplateScalarFieldEnum>
  }


  /**
   * SiteTemplate findMany
   */
  export type SiteTemplateFindManyArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * Filter, which SiteTemplates to fetch.
     */
    where?: SiteTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTemplates to fetch.
     */
    orderBy?: Enumerable<SiteTemplateOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteTemplates.
     */
    cursor?: SiteTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTemplates.
     */
    skip?: number
    distinct?: Enumerable<SiteTemplateScalarFieldEnum>
  }


  /**
   * SiteTemplate create
   */
  export type SiteTemplateCreateArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * The data needed to create a SiteTemplate.
     */
    data: XOR<SiteTemplateCreateInput, SiteTemplateUncheckedCreateInput>
  }


  /**
   * SiteTemplate createMany
   */
  export type SiteTemplateCreateManyArgs = {
    /**
     * The data used to create many SiteTemplates.
     */
    data: Enumerable<SiteTemplateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SiteTemplate update
   */
  export type SiteTemplateUpdateArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * The data needed to update a SiteTemplate.
     */
    data: XOR<SiteTemplateUpdateInput, SiteTemplateUncheckedUpdateInput>
    /**
     * Choose, which SiteTemplate to update.
     */
    where: SiteTemplateWhereUniqueInput
  }


  /**
   * SiteTemplate updateMany
   */
  export type SiteTemplateUpdateManyArgs = {
    /**
     * The data used to update SiteTemplates.
     */
    data: XOR<SiteTemplateUpdateManyMutationInput, SiteTemplateUncheckedUpdateManyInput>
    /**
     * Filter which SiteTemplates to update
     */
    where?: SiteTemplateWhereInput
  }


  /**
   * SiteTemplate upsert
   */
  export type SiteTemplateUpsertArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * The filter to search for the SiteTemplate to update in case it exists.
     */
    where: SiteTemplateWhereUniqueInput
    /**
     * In case the SiteTemplate found by the `where` argument doesn't exist, create a new SiteTemplate with this data.
     */
    create: XOR<SiteTemplateCreateInput, SiteTemplateUncheckedCreateInput>
    /**
     * In case the SiteTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteTemplateUpdateInput, SiteTemplateUncheckedUpdateInput>
  }


  /**
   * SiteTemplate delete
   */
  export type SiteTemplateDeleteArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
    /**
     * Filter which SiteTemplate to delete.
     */
    where: SiteTemplateWhereUniqueInput
  }


  /**
   * SiteTemplate deleteMany
   */
  export type SiteTemplateDeleteManyArgs = {
    /**
     * Filter which SiteTemplates to delete
     */
    where?: SiteTemplateWhereInput
  }


  /**
   * SiteTemplate.site
   */
  export type SiteTemplate$siteArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    where?: SiteWhereInput
    orderBy?: Enumerable<SiteOrderByWithRelationAndSearchRelevanceInput>
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SiteScalarFieldEnum>
  }


  /**
   * SiteTemplate without action
   */
  export type SiteTemplateArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplate
     */
    select?: SiteTemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateInclude | null
  }



  /**
   * Model SiteTemplateDataDef
   */


  export type AggregateSiteTemplateDataDef = {
    _count: SiteTemplateDataDefCountAggregateOutputType | null
    _avg: SiteTemplateDataDefAvgAggregateOutputType | null
    _sum: SiteTemplateDataDefSumAggregateOutputType | null
    _min: SiteTemplateDataDefMinAggregateOutputType | null
    _max: SiteTemplateDataDefMaxAggregateOutputType | null
  }

  export type SiteTemplateDataDefAvgAggregateOutputType = {
    id: number | null
    siteTemplateId: number | null
  }

  export type SiteTemplateDataDefSumAggregateOutputType = {
    id: number | null
    siteTemplateId: number | null
  }

  export type SiteTemplateDataDefMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    siteTemplateId: number | null
  }

  export type SiteTemplateDataDefMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    siteTemplateId: number | null
  }

  export type SiteTemplateDataDefCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    siteTemplateId: number
    defData: number
    _all: number
  }


  export type SiteTemplateDataDefAvgAggregateInputType = {
    id?: true
    siteTemplateId?: true
  }

  export type SiteTemplateDataDefSumAggregateInputType = {
    id?: true
    siteTemplateId?: true
  }

  export type SiteTemplateDataDefMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    siteTemplateId?: true
  }

  export type SiteTemplateDataDefMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    siteTemplateId?: true
  }

  export type SiteTemplateDataDefCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    siteTemplateId?: true
    defData?: true
    _all?: true
  }

  export type SiteTemplateDataDefAggregateArgs = {
    /**
     * Filter which SiteTemplateDataDef to aggregate.
     */
    where?: SiteTemplateDataDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTemplateDataDefs to fetch.
     */
    orderBy?: Enumerable<SiteTemplateDataDefOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteTemplateDataDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTemplateDataDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTemplateDataDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteTemplateDataDefs
    **/
    _count?: true | SiteTemplateDataDefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteTemplateDataDefAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteTemplateDataDefSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteTemplateDataDefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteTemplateDataDefMaxAggregateInputType
  }

  export type GetSiteTemplateDataDefAggregateType<T extends SiteTemplateDataDefAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteTemplateDataDef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteTemplateDataDef[P]>
      : GetScalarType<T[P], AggregateSiteTemplateDataDef[P]>
  }




  export type SiteTemplateDataDefGroupByArgs = {
    where?: SiteTemplateDataDefWhereInput
    orderBy?: Enumerable<SiteTemplateDataDefOrderByWithAggregationInput>
    by: SiteTemplateDataDefScalarFieldEnum[]
    having?: SiteTemplateDataDefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteTemplateDataDefCountAggregateInputType | true
    _avg?: SiteTemplateDataDefAvgAggregateInputType
    _sum?: SiteTemplateDataDefSumAggregateInputType
    _min?: SiteTemplateDataDefMinAggregateInputType
    _max?: SiteTemplateDataDefMaxAggregateInputType
  }


  export type SiteTemplateDataDefGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    siteTemplateId: number
    defData: JsonValue
    _count: SiteTemplateDataDefCountAggregateOutputType | null
    _avg: SiteTemplateDataDefAvgAggregateOutputType | null
    _sum: SiteTemplateDataDefSumAggregateOutputType | null
    _min: SiteTemplateDataDefMinAggregateOutputType | null
    _max: SiteTemplateDataDefMaxAggregateOutputType | null
  }

  type GetSiteTemplateDataDefGroupByPayload<T extends SiteTemplateDataDefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SiteTemplateDataDefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteTemplateDataDefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteTemplateDataDefGroupByOutputType[P]>
            : GetScalarType<T[P], SiteTemplateDataDefGroupByOutputType[P]>
        }
      >
    >


  export type SiteTemplateDataDefSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    siteTemplateId?: boolean
    defData?: boolean
    siteTemplate?: boolean | SiteTemplateArgs
  }


  export type SiteTemplateDataDefInclude = {
    siteTemplate?: boolean | SiteTemplateArgs
  }

  export type SiteTemplateDataDefGetPayload<S extends boolean | null | undefined | SiteTemplateDataDefArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SiteTemplateDataDef :
    S extends undefined ? never :
    S extends { include: any } & (SiteTemplateDataDefArgs | SiteTemplateDataDefFindManyArgs)
    ? SiteTemplateDataDef  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'siteTemplate' ? SiteTemplateGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SiteTemplateDataDefArgs | SiteTemplateDataDefFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'siteTemplate' ? SiteTemplateGetPayload<S['select'][P]> :  P extends keyof SiteTemplateDataDef ? SiteTemplateDataDef[P] : never
  } 
      : SiteTemplateDataDef


  type SiteTemplateDataDefCountArgs = 
    Omit<SiteTemplateDataDefFindManyArgs, 'select' | 'include'> & {
      select?: SiteTemplateDataDefCountAggregateInputType | true
    }

  export interface SiteTemplateDataDefDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SiteTemplateDataDef that matches the filter.
     * @param {SiteTemplateDataDefFindUniqueArgs} args - Arguments to find a SiteTemplateDataDef
     * @example
     * // Get one SiteTemplateDataDef
     * const siteTemplateDataDef = await prisma.siteTemplateDataDef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SiteTemplateDataDefFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SiteTemplateDataDefFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SiteTemplateDataDef'> extends True ? Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T>> : Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T> | null, null>

    /**
     * Find one SiteTemplateDataDef that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SiteTemplateDataDefFindUniqueOrThrowArgs} args - Arguments to find a SiteTemplateDataDef
     * @example
     * // Get one SiteTemplateDataDef
     * const siteTemplateDataDef = await prisma.siteTemplateDataDef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SiteTemplateDataDefFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SiteTemplateDataDefFindUniqueOrThrowArgs>
    ): Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T>>

    /**
     * Find the first SiteTemplateDataDef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateDataDefFindFirstArgs} args - Arguments to find a SiteTemplateDataDef
     * @example
     * // Get one SiteTemplateDataDef
     * const siteTemplateDataDef = await prisma.siteTemplateDataDef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SiteTemplateDataDefFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SiteTemplateDataDefFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SiteTemplateDataDef'> extends True ? Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T>> : Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T> | null, null>

    /**
     * Find the first SiteTemplateDataDef that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateDataDefFindFirstOrThrowArgs} args - Arguments to find a SiteTemplateDataDef
     * @example
     * // Get one SiteTemplateDataDef
     * const siteTemplateDataDef = await prisma.siteTemplateDataDef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SiteTemplateDataDefFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SiteTemplateDataDefFindFirstOrThrowArgs>
    ): Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T>>

    /**
     * Find zero or more SiteTemplateDataDefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateDataDefFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteTemplateDataDefs
     * const siteTemplateDataDefs = await prisma.siteTemplateDataDef.findMany()
     * 
     * // Get first 10 SiteTemplateDataDefs
     * const siteTemplateDataDefs = await prisma.siteTemplateDataDef.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteTemplateDataDefWithIdOnly = await prisma.siteTemplateDataDef.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SiteTemplateDataDefFindManyArgs>(
      args?: SelectSubset<T, SiteTemplateDataDefFindManyArgs>
    ): Prisma.PrismaPromise<Array<SiteTemplateDataDefGetPayload<T>>>

    /**
     * Create a SiteTemplateDataDef.
     * @param {SiteTemplateDataDefCreateArgs} args - Arguments to create a SiteTemplateDataDef.
     * @example
     * // Create one SiteTemplateDataDef
     * const SiteTemplateDataDef = await prisma.siteTemplateDataDef.create({
     *   data: {
     *     // ... data to create a SiteTemplateDataDef
     *   }
     * })
     * 
    **/
    create<T extends SiteTemplateDataDefCreateArgs>(
      args: SelectSubset<T, SiteTemplateDataDefCreateArgs>
    ): Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T>>

    /**
     * Create many SiteTemplateDataDefs.
     *     @param {SiteTemplateDataDefCreateManyArgs} args - Arguments to create many SiteTemplateDataDefs.
     *     @example
     *     // Create many SiteTemplateDataDefs
     *     const siteTemplateDataDef = await prisma.siteTemplateDataDef.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SiteTemplateDataDefCreateManyArgs>(
      args?: SelectSubset<T, SiteTemplateDataDefCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SiteTemplateDataDef.
     * @param {SiteTemplateDataDefDeleteArgs} args - Arguments to delete one SiteTemplateDataDef.
     * @example
     * // Delete one SiteTemplateDataDef
     * const SiteTemplateDataDef = await prisma.siteTemplateDataDef.delete({
     *   where: {
     *     // ... filter to delete one SiteTemplateDataDef
     *   }
     * })
     * 
    **/
    delete<T extends SiteTemplateDataDefDeleteArgs>(
      args: SelectSubset<T, SiteTemplateDataDefDeleteArgs>
    ): Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T>>

    /**
     * Update one SiteTemplateDataDef.
     * @param {SiteTemplateDataDefUpdateArgs} args - Arguments to update one SiteTemplateDataDef.
     * @example
     * // Update one SiteTemplateDataDef
     * const siteTemplateDataDef = await prisma.siteTemplateDataDef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SiteTemplateDataDefUpdateArgs>(
      args: SelectSubset<T, SiteTemplateDataDefUpdateArgs>
    ): Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T>>

    /**
     * Delete zero or more SiteTemplateDataDefs.
     * @param {SiteTemplateDataDefDeleteManyArgs} args - Arguments to filter SiteTemplateDataDefs to delete.
     * @example
     * // Delete a few SiteTemplateDataDefs
     * const { count } = await prisma.siteTemplateDataDef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SiteTemplateDataDefDeleteManyArgs>(
      args?: SelectSubset<T, SiteTemplateDataDefDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteTemplateDataDefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateDataDefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteTemplateDataDefs
     * const siteTemplateDataDef = await prisma.siteTemplateDataDef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SiteTemplateDataDefUpdateManyArgs>(
      args: SelectSubset<T, SiteTemplateDataDefUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SiteTemplateDataDef.
     * @param {SiteTemplateDataDefUpsertArgs} args - Arguments to update or create a SiteTemplateDataDef.
     * @example
     * // Update or create a SiteTemplateDataDef
     * const siteTemplateDataDef = await prisma.siteTemplateDataDef.upsert({
     *   create: {
     *     // ... data to create a SiteTemplateDataDef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteTemplateDataDef we want to update
     *   }
     * })
    **/
    upsert<T extends SiteTemplateDataDefUpsertArgs>(
      args: SelectSubset<T, SiteTemplateDataDefUpsertArgs>
    ): Prisma__SiteTemplateDataDefClient<SiteTemplateDataDefGetPayload<T>>

    /**
     * Count the number of SiteTemplateDataDefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateDataDefCountArgs} args - Arguments to filter SiteTemplateDataDefs to count.
     * @example
     * // Count the number of SiteTemplateDataDefs
     * const count = await prisma.siteTemplateDataDef.count({
     *   where: {
     *     // ... the filter for the SiteTemplateDataDefs we want to count
     *   }
     * })
    **/
    count<T extends SiteTemplateDataDefCountArgs>(
      args?: Subset<T, SiteTemplateDataDefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteTemplateDataDefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteTemplateDataDef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateDataDefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteTemplateDataDefAggregateArgs>(args: Subset<T, SiteTemplateDataDefAggregateArgs>): Prisma.PrismaPromise<GetSiteTemplateDataDefAggregateType<T>>

    /**
     * Group by SiteTemplateDataDef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteTemplateDataDefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteTemplateDataDefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteTemplateDataDefGroupByArgs['orderBy'] }
        : { orderBy?: SiteTemplateDataDefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteTemplateDataDefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteTemplateDataDefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteTemplateDataDef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SiteTemplateDataDefClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    siteTemplate<T extends SiteTemplateArgs= {}>(args?: Subset<T, SiteTemplateArgs>): Prisma__SiteTemplateClient<SiteTemplateGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SiteTemplateDataDef base type for findUnique actions
   */
  export type SiteTemplateDataDefFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * Filter, which SiteTemplateDataDef to fetch.
     */
    where: SiteTemplateDataDefWhereUniqueInput
  }

  /**
   * SiteTemplateDataDef findUnique
   */
  export interface SiteTemplateDataDefFindUniqueArgs extends SiteTemplateDataDefFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SiteTemplateDataDef findUniqueOrThrow
   */
  export type SiteTemplateDataDefFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * Filter, which SiteTemplateDataDef to fetch.
     */
    where: SiteTemplateDataDefWhereUniqueInput
  }


  /**
   * SiteTemplateDataDef base type for findFirst actions
   */
  export type SiteTemplateDataDefFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * Filter, which SiteTemplateDataDef to fetch.
     */
    where?: SiteTemplateDataDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTemplateDataDefs to fetch.
     */
    orderBy?: Enumerable<SiteTemplateDataDefOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteTemplateDataDefs.
     */
    cursor?: SiteTemplateDataDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTemplateDataDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTemplateDataDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteTemplateDataDefs.
     */
    distinct?: Enumerable<SiteTemplateDataDefScalarFieldEnum>
  }

  /**
   * SiteTemplateDataDef findFirst
   */
  export interface SiteTemplateDataDefFindFirstArgs extends SiteTemplateDataDefFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SiteTemplateDataDef findFirstOrThrow
   */
  export type SiteTemplateDataDefFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * Filter, which SiteTemplateDataDef to fetch.
     */
    where?: SiteTemplateDataDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTemplateDataDefs to fetch.
     */
    orderBy?: Enumerable<SiteTemplateDataDefOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteTemplateDataDefs.
     */
    cursor?: SiteTemplateDataDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTemplateDataDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTemplateDataDefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteTemplateDataDefs.
     */
    distinct?: Enumerable<SiteTemplateDataDefScalarFieldEnum>
  }


  /**
   * SiteTemplateDataDef findMany
   */
  export type SiteTemplateDataDefFindManyArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * Filter, which SiteTemplateDataDefs to fetch.
     */
    where?: SiteTemplateDataDefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteTemplateDataDefs to fetch.
     */
    orderBy?: Enumerable<SiteTemplateDataDefOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteTemplateDataDefs.
     */
    cursor?: SiteTemplateDataDefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteTemplateDataDefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteTemplateDataDefs.
     */
    skip?: number
    distinct?: Enumerable<SiteTemplateDataDefScalarFieldEnum>
  }


  /**
   * SiteTemplateDataDef create
   */
  export type SiteTemplateDataDefCreateArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * The data needed to create a SiteTemplateDataDef.
     */
    data: XOR<SiteTemplateDataDefCreateInput, SiteTemplateDataDefUncheckedCreateInput>
  }


  /**
   * SiteTemplateDataDef createMany
   */
  export type SiteTemplateDataDefCreateManyArgs = {
    /**
     * The data used to create many SiteTemplateDataDefs.
     */
    data: Enumerable<SiteTemplateDataDefCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SiteTemplateDataDef update
   */
  export type SiteTemplateDataDefUpdateArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * The data needed to update a SiteTemplateDataDef.
     */
    data: XOR<SiteTemplateDataDefUpdateInput, SiteTemplateDataDefUncheckedUpdateInput>
    /**
     * Choose, which SiteTemplateDataDef to update.
     */
    where: SiteTemplateDataDefWhereUniqueInput
  }


  /**
   * SiteTemplateDataDef updateMany
   */
  export type SiteTemplateDataDefUpdateManyArgs = {
    /**
     * The data used to update SiteTemplateDataDefs.
     */
    data: XOR<SiteTemplateDataDefUpdateManyMutationInput, SiteTemplateDataDefUncheckedUpdateManyInput>
    /**
     * Filter which SiteTemplateDataDefs to update
     */
    where?: SiteTemplateDataDefWhereInput
  }


  /**
   * SiteTemplateDataDef upsert
   */
  export type SiteTemplateDataDefUpsertArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * The filter to search for the SiteTemplateDataDef to update in case it exists.
     */
    where: SiteTemplateDataDefWhereUniqueInput
    /**
     * In case the SiteTemplateDataDef found by the `where` argument doesn't exist, create a new SiteTemplateDataDef with this data.
     */
    create: XOR<SiteTemplateDataDefCreateInput, SiteTemplateDataDefUncheckedCreateInput>
    /**
     * In case the SiteTemplateDataDef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteTemplateDataDefUpdateInput, SiteTemplateDataDefUncheckedUpdateInput>
  }


  /**
   * SiteTemplateDataDef delete
   */
  export type SiteTemplateDataDefDeleteArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
    /**
     * Filter which SiteTemplateDataDef to delete.
     */
    where: SiteTemplateDataDefWhereUniqueInput
  }


  /**
   * SiteTemplateDataDef deleteMany
   */
  export type SiteTemplateDataDefDeleteManyArgs = {
    /**
     * Filter which SiteTemplateDataDefs to delete
     */
    where?: SiteTemplateDataDefWhereInput
  }


  /**
   * SiteTemplateDataDef without action
   */
  export type SiteTemplateDataDefArgs = {
    /**
     * Select specific fields to fetch from the SiteTemplateDataDef
     */
    select?: SiteTemplateDataDefSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteTemplateDataDefInclude | null
  }



  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    extendData: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    extendData?: true
    _all?: true
  }

  export type CustomerAggregateArgs = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: CustomerScalarFieldEnum[]
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    extendData: JsonValue | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    extendData?: boolean
    site?: boolean | Customer$siteArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }


  export type CustomerInclude = {
    site?: boolean | Customer$siteArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }

  export type CustomerGetPayload<S extends boolean | null | undefined | CustomerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Customer :
    S extends undefined ? never :
    S extends { include: any } & (CustomerArgs | CustomerFindManyArgs)
    ? Customer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'site' ? Array < SiteGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerArgs | CustomerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'site' ? Array < SiteGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Customer ? Customer[P] : never
  } 
      : Customer


  type CustomerCountArgs = 
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? Prisma__CustomerClient<CustomerGetPayload<T>> : Prisma__CustomerClient<CustomerGetPayload<T> | null, null>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? Prisma__CustomerClient<CustomerGetPayload<T>> : Prisma__CustomerClient<CustomerGetPayload<T> | null, null>

    /**
     * Find the first Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs>
    ): Prisma.PrismaPromise<Array<CustomerGetPayload<T>>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    site<T extends Customer$siteArgs= {}>(args?: Subset<T, Customer$siteArgs>): Prisma.PrismaPromise<Array<SiteGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customer base type for findUnique actions
   */
  export type CustomerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUnique
   */
  export interface CustomerFindUniqueArgs extends CustomerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer base type for findFirst actions
   */
  export type CustomerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }

  /**
   * Customer findFirst
   */
  export interface CustomerFindFirstArgs extends CustomerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs = {
    /**
     * The data used to create many Customers.
     */
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer.site
   */
  export type Customer$siteArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    where?: SiteWhereInput
    orderBy?: Enumerable<SiteOrderByWithRelationAndSearchRelevanceInput>
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SiteScalarFieldEnum>
  }


  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
  }



  /**
   * Model Site
   */


  export type AggregateSite = {
    _count: SiteCountAggregateOutputType | null
    _avg: SiteAvgAggregateOutputType | null
    _sum: SiteSumAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  export type SiteAvgAggregateOutputType = {
    id: number | null
    siteTemplateId: number | null
    customerId: number | null
  }

  export type SiteSumAggregateOutputType = {
    id: number | null
    siteTemplateId: number | null
    customerId: number | null
  }

  export type SiteMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    cosUrl: string | null
    siteTemplateId: number | null
    customerId: number | null
  }

  export type SiteMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    cosUrl: string | null
    siteTemplateId: number | null
    customerId: number | null
  }

  export type SiteCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    cosUrl: number
    siteTemplateId: number
    customerId: number
    slotData: number
    _all: number
  }


  export type SiteAvgAggregateInputType = {
    id?: true
    siteTemplateId?: true
    customerId?: true
  }

  export type SiteSumAggregateInputType = {
    id?: true
    siteTemplateId?: true
    customerId?: true
  }

  export type SiteMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    cosUrl?: true
    siteTemplateId?: true
    customerId?: true
  }

  export type SiteMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    cosUrl?: true
    siteTemplateId?: true
    customerId?: true
  }

  export type SiteCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    cosUrl?: true
    siteTemplateId?: true
    customerId?: true
    slotData?: true
    _all?: true
  }

  export type SiteAggregateArgs = {
    /**
     * Filter which Site to aggregate.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: Enumerable<SiteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sites
    **/
    _count?: true | SiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteMaxAggregateInputType
  }

  export type GetSiteAggregateType<T extends SiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSite[P]>
      : GetScalarType<T[P], AggregateSite[P]>
  }




  export type SiteGroupByArgs = {
    where?: SiteWhereInput
    orderBy?: Enumerable<SiteOrderByWithAggregationInput>
    by: SiteScalarFieldEnum[]
    having?: SiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCountAggregateInputType | true
    _avg?: SiteAvgAggregateInputType
    _sum?: SiteSumAggregateInputType
    _min?: SiteMinAggregateInputType
    _max?: SiteMaxAggregateInputType
  }


  export type SiteGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    cosUrl: string
    siteTemplateId: number
    customerId: number
    slotData: JsonValue
    _count: SiteCountAggregateOutputType | null
    _avg: SiteAvgAggregateOutputType | null
    _sum: SiteSumAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  type GetSiteGroupByPayload<T extends SiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteGroupByOutputType[P]>
            : GetScalarType<T[P], SiteGroupByOutputType[P]>
        }
      >
    >


  export type SiteSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    cosUrl?: boolean
    siteTemplateId?: boolean
    customerId?: boolean
    slotData?: boolean
    siteTemplate?: boolean | SiteTemplateArgs
    customer?: boolean | CustomerArgs
  }


  export type SiteInclude = {
    siteTemplate?: boolean | SiteTemplateArgs
    customer?: boolean | CustomerArgs
  }

  export type SiteGetPayload<S extends boolean | null | undefined | SiteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Site :
    S extends undefined ? never :
    S extends { include: any } & (SiteArgs | SiteFindManyArgs)
    ? Site  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'siteTemplate' ? SiteTemplateGetPayload<S['include'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SiteArgs | SiteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'siteTemplate' ? SiteTemplateGetPayload<S['select'][P]> :
        P extends 'customer' ? CustomerGetPayload<S['select'][P]> :  P extends keyof Site ? Site[P] : never
  } 
      : Site


  type SiteCountArgs = 
    Omit<SiteFindManyArgs, 'select' | 'include'> & {
      select?: SiteCountAggregateInputType | true
    }

  export interface SiteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Site that matches the filter.
     * @param {SiteFindUniqueArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SiteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SiteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Site'> extends True ? Prisma__SiteClient<SiteGetPayload<T>> : Prisma__SiteClient<SiteGetPayload<T> | null, null>

    /**
     * Find one Site that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SiteFindUniqueOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SiteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SiteFindUniqueOrThrowArgs>
    ): Prisma__SiteClient<SiteGetPayload<T>>

    /**
     * Find the first Site that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SiteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SiteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Site'> extends True ? Prisma__SiteClient<SiteGetPayload<T>> : Prisma__SiteClient<SiteGetPayload<T> | null, null>

    /**
     * Find the first Site that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SiteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SiteFindFirstOrThrowArgs>
    ): Prisma__SiteClient<SiteGetPayload<T>>

    /**
     * Find zero or more Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sites
     * const sites = await prisma.site.findMany()
     * 
     * // Get first 10 Sites
     * const sites = await prisma.site.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteWithIdOnly = await prisma.site.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SiteFindManyArgs>(
      args?: SelectSubset<T, SiteFindManyArgs>
    ): Prisma.PrismaPromise<Array<SiteGetPayload<T>>>

    /**
     * Create a Site.
     * @param {SiteCreateArgs} args - Arguments to create a Site.
     * @example
     * // Create one Site
     * const Site = await prisma.site.create({
     *   data: {
     *     // ... data to create a Site
     *   }
     * })
     * 
    **/
    create<T extends SiteCreateArgs>(
      args: SelectSubset<T, SiteCreateArgs>
    ): Prisma__SiteClient<SiteGetPayload<T>>

    /**
     * Create many Sites.
     *     @param {SiteCreateManyArgs} args - Arguments to create many Sites.
     *     @example
     *     // Create many Sites
     *     const site = await prisma.site.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SiteCreateManyArgs>(
      args?: SelectSubset<T, SiteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Site.
     * @param {SiteDeleteArgs} args - Arguments to delete one Site.
     * @example
     * // Delete one Site
     * const Site = await prisma.site.delete({
     *   where: {
     *     // ... filter to delete one Site
     *   }
     * })
     * 
    **/
    delete<T extends SiteDeleteArgs>(
      args: SelectSubset<T, SiteDeleteArgs>
    ): Prisma__SiteClient<SiteGetPayload<T>>

    /**
     * Update one Site.
     * @param {SiteUpdateArgs} args - Arguments to update one Site.
     * @example
     * // Update one Site
     * const site = await prisma.site.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SiteUpdateArgs>(
      args: SelectSubset<T, SiteUpdateArgs>
    ): Prisma__SiteClient<SiteGetPayload<T>>

    /**
     * Delete zero or more Sites.
     * @param {SiteDeleteManyArgs} args - Arguments to filter Sites to delete.
     * @example
     * // Delete a few Sites
     * const { count } = await prisma.site.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SiteDeleteManyArgs>(
      args?: SelectSubset<T, SiteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SiteUpdateManyArgs>(
      args: SelectSubset<T, SiteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Site.
     * @param {SiteUpsertArgs} args - Arguments to update or create a Site.
     * @example
     * // Update or create a Site
     * const site = await prisma.site.upsert({
     *   create: {
     *     // ... data to create a Site
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Site we want to update
     *   }
     * })
    **/
    upsert<T extends SiteUpsertArgs>(
      args: SelectSubset<T, SiteUpsertArgs>
    ): Prisma__SiteClient<SiteGetPayload<T>>

    /**
     * Count the number of Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCountArgs} args - Arguments to filter Sites to count.
     * @example
     * // Count the number of Sites
     * const count = await prisma.site.count({
     *   where: {
     *     // ... the filter for the Sites we want to count
     *   }
     * })
    **/
    count<T extends SiteCountArgs>(
      args?: Subset<T, SiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteAggregateArgs>(args: Subset<T, SiteAggregateArgs>): Prisma.PrismaPromise<GetSiteAggregateType<T>>

    /**
     * Group by Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteGroupByArgs['orderBy'] }
        : { orderBy?: SiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Site.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SiteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    siteTemplate<T extends SiteTemplateArgs= {}>(args?: Subset<T, SiteTemplateArgs>): Prisma__SiteTemplateClient<SiteTemplateGetPayload<T> | Null>;

    customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Site base type for findUnique actions
   */
  export type SiteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findUnique
   */
  export interface SiteFindUniqueArgs extends SiteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Site findUniqueOrThrow
   */
  export type SiteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }


  /**
   * Site base type for findFirst actions
   */
  export type SiteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: Enumerable<SiteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: Enumerable<SiteScalarFieldEnum>
  }

  /**
   * Site findFirst
   */
  export interface SiteFindFirstArgs extends SiteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Site findFirstOrThrow
   */
  export type SiteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: Enumerable<SiteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: Enumerable<SiteScalarFieldEnum>
  }


  /**
   * Site findMany
   */
  export type SiteFindManyArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * Filter, which Sites to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: Enumerable<SiteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    distinct?: Enumerable<SiteScalarFieldEnum>
  }


  /**
   * Site create
   */
  export type SiteCreateArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * The data needed to create a Site.
     */
    data: XOR<SiteCreateInput, SiteUncheckedCreateInput>
  }


  /**
   * Site createMany
   */
  export type SiteCreateManyArgs = {
    /**
     * The data used to create many Sites.
     */
    data: Enumerable<SiteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Site update
   */
  export type SiteUpdateArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * The data needed to update a Site.
     */
    data: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
    /**
     * Choose, which Site to update.
     */
    where: SiteWhereUniqueInput
  }


  /**
   * Site updateMany
   */
  export type SiteUpdateManyArgs = {
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
  }


  /**
   * Site upsert
   */
  export type SiteUpsertArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * The filter to search for the Site to update in case it exists.
     */
    where: SiteWhereUniqueInput
    /**
     * In case the Site found by the `where` argument doesn't exist, create a new Site with this data.
     */
    create: XOR<SiteCreateInput, SiteUncheckedCreateInput>
    /**
     * In case the Site was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
  }


  /**
   * Site delete
   */
  export type SiteDeleteArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
    /**
     * Filter which Site to delete.
     */
    where: SiteWhereUniqueInput
  }


  /**
   * Site deleteMany
   */
  export type SiteDeleteManyArgs = {
    /**
     * Filter which Sites to delete
     */
    where?: SiteWhereInput
  }


  /**
   * Site without action
   */
  export type SiteArgs = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SiteInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    accounts?: boolean | User$accountsArgs
    sessions?: boolean | User$sessionsArgs
    projects?: boolean | User$projectsArgs
    links?: boolean | User$linksArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    accounts?: boolean | User$accountsArgs
    sessions?: boolean | User$sessionsArgs
    projects?: boolean | User$projectsArgs
    links?: boolean | User$linksArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'accounts' ? Array < AccountGetPayload<S['include'][P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<S['include'][P]>>  :
        P extends 'projects' ? Array < ProjectUsersGetPayload<S['include'][P]>>  :
        P extends 'links' ? Array < LinkGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'accounts' ? Array < AccountGetPayload<S['select'][P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<S['select'][P]>>  :
        P extends 'projects' ? Array < ProjectUsersGetPayload<S['select'][P]>>  :
        P extends 'links' ? Array < LinkGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    accounts<T extends User$accountsArgs= {}>(args?: Subset<T, User$accountsArgs>): Prisma.PrismaPromise<Array<AccountGetPayload<T>>| Null>;

    sessions<T extends User$sessionsArgs= {}>(args?: Subset<T, User$sessionsArgs>): Prisma.PrismaPromise<Array<SessionGetPayload<T>>| Null>;

    projects<T extends User$projectsArgs= {}>(args?: Subset<T, User$projectsArgs>): Prisma.PrismaPromise<Array<ProjectUsersGetPayload<T>>| Null>;

    links<T extends User$linksArgs= {}>(args?: Subset<T, User$linksArgs>): Prisma.PrismaPromise<Array<LinkGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * User.sessions
   */
  export type User$sessionsArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithRelationAndSearchRelevanceInput>
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * User.projects
   */
  export type User$projectsArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    where?: ProjectUsersWhereInput
    orderBy?: Enumerable<ProjectUsersOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectUsersScalarFieldEnum>
  }


  /**
   * User.links
   */
  export type User$linksArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    where?: LinkWhereInput
    orderBy?: Enumerable<LinkOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    refresh_token_expires_in: number | null
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    refresh_token_expires_in: number | null
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    refresh_token_expires_in: number | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    refresh_token_expires_in: number | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    refresh_token_expires_in: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    refresh_token_expires_in?: true
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    refresh_token_expires_in?: true
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    refresh_token_expires_in?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    refresh_token_expires_in?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    refresh_token_expires_in?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: AccountScalarFieldEnum[]
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    refresh_token_expires_in: number | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    refresh_token_expires_in?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserArgs
  }


  export type AccountInclude = {
    user?: boolean | UserArgs
  }

  export type AccountGetPayload<S extends boolean | null | undefined | AccountArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Account :
    S extends undefined ? never :
    S extends { include: any } & (AccountArgs | AccountFindManyArgs)
    ? Account  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AccountArgs | AccountFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Account ? Account[P] : never
  } 
      : Account


  type AccountCountArgs = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? Prisma__AccountClient<AccountGetPayload<T>> : Prisma__AccountClient<AccountGetPayload<T> | null, null>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? Prisma__AccountClient<AccountGetPayload<T>> : Prisma__AccountClient<AccountGetPayload<T> | null, null>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): Prisma.PrismaPromise<Array<AccountGetPayload<T>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): Prisma__AccountClient<AccountGetPayload<T>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUnique
   */
  export interface AccountFindUniqueArgs extends AccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account findFirst
   */
  export interface AccountFindFirstArgs extends AccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     */
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: SessionScalarFieldEnum[]
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserArgs
  }


  export type SessionInclude = {
    user?: boolean | UserArgs
  }

  export type SessionGetPayload<S extends boolean | null | undefined | SessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Session :
    S extends undefined ? never :
    S extends { include: any } & (SessionArgs | SessionFindManyArgs)
    ? Session  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SessionArgs | SessionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Session ? Session[P] : never
  } 
      : Session


  type SessionCountArgs = 
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? Prisma__SessionClient<SessionGetPayload<T>> : Prisma__SessionClient<SessionGetPayload<T> | null, null>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? Prisma__SessionClient<SessionGetPayload<T>> : Prisma__SessionClient<SessionGetPayload<T> | null, null>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): Prisma.PrismaPromise<Array<SessionGetPayload<T>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): Prisma__SessionClient<SessionGetPayload<T>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Session base type for findUnique actions
   */
  export type SessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUnique
   */
  export interface SessionFindUniqueArgs extends SessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session base type for findFirst actions
   */
  export type SessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * Session findFirst
   */
  export interface SessionFindFirstArgs extends SessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    /**
     * The data used to create many Sessions.
     */
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude | null
  }



  /**
   * Model VerificationToken
   */


  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs = {
    where?: VerificationTokenWhereInput
    orderBy?: Enumerable<VerificationTokenOrderByWithAggregationInput>
    by: VerificationTokenScalarFieldEnum[]
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }


  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VerificationToken :
    S extends undefined ? never :
    S extends { include: any } & (VerificationTokenArgs | VerificationTokenFindManyArgs)
    ? VerificationToken 
    : S extends { select: any } & (VerificationTokenArgs | VerificationTokenFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VerificationToken ? VerificationToken[P] : never
  } 
      : VerificationToken


  type VerificationTokenCountArgs = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VerificationToken'> extends True ? Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>> : Prisma__VerificationTokenClient<VerificationTokenGetPayload<T> | null, null>

    /**
     * Find one VerificationToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs>
    ): Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VerificationToken'> extends True ? Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>> : Prisma__VerificationTokenClient<VerificationTokenGetPayload<T> | null, null>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs>
    ): Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs>
    ): Prisma.PrismaPromise<Array<VerificationTokenGetPayload<T>>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs>
    ): Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs>
    ): Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs>
    ): Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs>
    ): Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerificationTokenClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VerificationToken base type for findUnique actions
   */
  export type VerificationTokenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUnique
   */
  export interface VerificationTokenFindUniqueArgs extends VerificationTokenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken base type for findFirst actions
   */
  export type VerificationTokenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }

  /**
   * VerificationToken findFirst
   */
  export interface VerificationTokenFindFirstArgs extends VerificationTokenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }


  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: Enumerable<VerificationTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken without action
   */
  export type VerificationTokenArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect | null
  }



  /**
   * Model Project
   */


  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    usage: number | null
    usageLimit: number | null
    billingCycleStart: number | null
  }

  export type ProjectSumAggregateOutputType = {
    usage: number | null
    usageLimit: number | null
    billingCycleStart: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    password: string | null
    type: string | null
    usage: number | null
    usageLimit: number | null
    plan: string | null
    stripeId: string | null
    billingCycleStart: number | null
    region: string | null
    endpoint: string | null
    bucket: string | null
    useHost: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    password: string | null
    type: string | null
    usage: number | null
    usageLimit: number | null
    plan: string | null
    stripeId: string | null
    billingCycleStart: number | null
    region: string | null
    endpoint: string | null
    bucket: string | null
    useHost: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    password: number
    type: number
    usage: number
    usageLimit: number
    plan: number
    stripeId: number
    billingCycleStart: number
    region: number
    endpoint: number
    bucket: number
    useHost: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    usage?: true
    usageLimit?: true
    billingCycleStart?: true
  }

  export type ProjectSumAggregateInputType = {
    usage?: true
    usageLimit?: true
    billingCycleStart?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    password?: true
    type?: true
    usage?: true
    usageLimit?: true
    plan?: true
    stripeId?: true
    billingCycleStart?: true
    region?: true
    endpoint?: true
    bucket?: true
    useHost?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    password?: true
    type?: true
    usage?: true
    usageLimit?: true
    plan?: true
    stripeId?: true
    billingCycleStart?: true
    region?: true
    endpoint?: true
    bucket?: true
    useHost?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    password?: true
    type?: true
    usage?: true
    usageLimit?: true
    plan?: true
    stripeId?: true
    billingCycleStart?: true
    region?: true
    endpoint?: true
    bucket?: true
    useHost?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type ProjectAggregateArgs = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs = {
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByWithAggregationInput>
    by: ProjectScalarFieldEnum[]
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }


  export type ProjectGroupByOutputType = {
    id: string
    name: string
    slug: string
    logo: string | null
    password: string | null
    type: string
    usage: number
    usageLimit: number
    plan: string
    stripeId: string | null
    billingCycleStart: number | null
    region: string | null
    endpoint: string | null
    bucket: string | null
    useHost: string | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    password?: boolean
    type?: boolean
    usage?: boolean
    usageLimit?: boolean
    plan?: boolean
    stripeId?: boolean
    billingCycleStart?: boolean
    region?: boolean
    endpoint?: boolean
    bucket?: boolean
    useHost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    users?: boolean | Project$usersArgs
    invites?: boolean | Project$invitesArgs
    sentEmails?: boolean | Project$sentEmailsArgs
    domains?: boolean | Project$domainsArgs
    links?: boolean | Project$linksArgs
    tags?: boolean | Project$tagsArgs
    _count?: boolean | ProjectCountOutputTypeArgs
  }


  export type ProjectInclude = {
    users?: boolean | Project$usersArgs
    invites?: boolean | Project$invitesArgs
    sentEmails?: boolean | Project$sentEmailsArgs
    domains?: boolean | Project$domainsArgs
    links?: boolean | Project$linksArgs
    tags?: boolean | Project$tagsArgs
    _count?: boolean | ProjectCountOutputTypeArgs
  }

  export type ProjectGetPayload<S extends boolean | null | undefined | ProjectArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Project :
    S extends undefined ? never :
    S extends { include: any } & (ProjectArgs | ProjectFindManyArgs)
    ? Project  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'users' ? Array < ProjectUsersGetPayload<S['include'][P]>>  :
        P extends 'invites' ? Array < ProjectInviteGetPayload<S['include'][P]>>  :
        P extends 'sentEmails' ? Array < SentEmailGetPayload<S['include'][P]>>  :
        P extends 'domains' ? Array < DomainGetPayload<S['include'][P]>>  :
        P extends 'links' ? Array < LinkGetPayload<S['include'][P]>>  :
        P extends 'tags' ? Array < TagGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProjectCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectArgs | ProjectFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'users' ? Array < ProjectUsersGetPayload<S['select'][P]>>  :
        P extends 'invites' ? Array < ProjectInviteGetPayload<S['select'][P]>>  :
        P extends 'sentEmails' ? Array < SentEmailGetPayload<S['select'][P]>>  :
        P extends 'domains' ? Array < DomainGetPayload<S['select'][P]>>  :
        P extends 'links' ? Array < LinkGetPayload<S['select'][P]>>  :
        P extends 'tags' ? Array < TagGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProjectCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Project ? Project[P] : never
  } 
      : Project


  type ProjectCountArgs = 
    Omit<ProjectFindManyArgs, 'select' | 'include'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Project'> extends True ? Prisma__ProjectClient<ProjectGetPayload<T>> : Prisma__ProjectClient<ProjectGetPayload<T> | null, null>

    /**
     * Find one Project that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindUniqueOrThrowArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Project'> extends True ? Prisma__ProjectClient<ProjectGetPayload<T>> : Prisma__ProjectClient<ProjectGetPayload<T> | null, null>

    /**
     * Find the first Project that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectFindFirstOrThrowArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs>(
      args?: SelectSubset<T, ProjectFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProjectGetPayload<T>>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs>(
      args: SelectSubset<T, ProjectCreateArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Create many Projects.
     *     @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     *     @example
     *     // Create many Projects
     *     const project = await prisma.project.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectCreateManyArgs>(
      args?: SelectSubset<T, ProjectCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs>(
      args: SelectSubset<T, ProjectDeleteArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs>(
      args: SelectSubset<T, ProjectUpdateArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs>(
      args?: SelectSubset<T, ProjectDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs>(
      args: SelectSubset<T, ProjectUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs>(
      args: SelectSubset<T, ProjectUpsertArgs>
    ): Prisma__ProjectClient<ProjectGetPayload<T>>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends Project$usersArgs= {}>(args?: Subset<T, Project$usersArgs>): Prisma.PrismaPromise<Array<ProjectUsersGetPayload<T>>| Null>;

    invites<T extends Project$invitesArgs= {}>(args?: Subset<T, Project$invitesArgs>): Prisma.PrismaPromise<Array<ProjectInviteGetPayload<T>>| Null>;

    sentEmails<T extends Project$sentEmailsArgs= {}>(args?: Subset<T, Project$sentEmailsArgs>): Prisma.PrismaPromise<Array<SentEmailGetPayload<T>>| Null>;

    domains<T extends Project$domainsArgs= {}>(args?: Subset<T, Project$domainsArgs>): Prisma.PrismaPromise<Array<DomainGetPayload<T>>| Null>;

    links<T extends Project$linksArgs= {}>(args?: Subset<T, Project$linksArgs>): Prisma.PrismaPromise<Array<LinkGetPayload<T>>| Null>;

    tags<T extends Project$tagsArgs= {}>(args?: Subset<T, Project$tagsArgs>): Prisma.PrismaPromise<Array<TagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Project base type for findUnique actions
   */
  export type ProjectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUnique
   */
  export interface ProjectFindUniqueArgs extends ProjectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project base type for findFirst actions
   */
  export type ProjectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }

  /**
   * Project findFirst
   */
  export interface ProjectFindFirstArgs extends ProjectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project findMany
   */
  export type ProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: Enumerable<ProjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project create
   */
  export type ProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }


  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs = {
    /**
     * The data used to create many Projects.
     */
    data: Enumerable<ProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Project update
   */
  export type ProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }


  /**
   * Project upsert
   */
  export type ProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }


  /**
   * Project delete
   */
  export type ProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }


  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }


  /**
   * Project.users
   */
  export type Project$usersArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    where?: ProjectUsersWhereInput
    orderBy?: Enumerable<ProjectUsersOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectUsersScalarFieldEnum>
  }


  /**
   * Project.invites
   */
  export type Project$invitesArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    where?: ProjectInviteWhereInput
    orderBy?: Enumerable<ProjectInviteOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ProjectInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProjectInviteScalarFieldEnum>
  }


  /**
   * Project.sentEmails
   */
  export type Project$sentEmailsArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    where?: SentEmailWhereInput
    orderBy?: Enumerable<SentEmailOrderByWithRelationAndSearchRelevanceInput>
    cursor?: SentEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SentEmailScalarFieldEnum>
  }


  /**
   * Project.domains
   */
  export type Project$domainsArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    where?: DomainWhereInput
    orderBy?: Enumerable<DomainOrderByWithRelationAndSearchRelevanceInput>
    cursor?: DomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DomainScalarFieldEnum>
  }


  /**
   * Project.links
   */
  export type Project$linksArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    where?: LinkWhereInput
    orderBy?: Enumerable<LinkOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * Project.tags
   */
  export type Project$tagsArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithRelationAndSearchRelevanceInput>
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Project without action
   */
  export type ProjectArgs = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInclude | null
  }



  /**
   * Model ProjectInvite
   */


  export type AggregateProjectInvite = {
    _count: ProjectInviteCountAggregateOutputType | null
    _min: ProjectInviteMinAggregateOutputType | null
    _max: ProjectInviteMaxAggregateOutputType | null
  }

  export type ProjectInviteMinAggregateOutputType = {
    email: string | null
    expires: Date | null
    projectId: string | null
    createdAt: Date | null
  }

  export type ProjectInviteMaxAggregateOutputType = {
    email: string | null
    expires: Date | null
    projectId: string | null
    createdAt: Date | null
  }

  export type ProjectInviteCountAggregateOutputType = {
    email: number
    expires: number
    projectId: number
    createdAt: number
    _all: number
  }


  export type ProjectInviteMinAggregateInputType = {
    email?: true
    expires?: true
    projectId?: true
    createdAt?: true
  }

  export type ProjectInviteMaxAggregateInputType = {
    email?: true
    expires?: true
    projectId?: true
    createdAt?: true
  }

  export type ProjectInviteCountAggregateInputType = {
    email?: true
    expires?: true
    projectId?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectInviteAggregateArgs = {
    /**
     * Filter which ProjectInvite to aggregate.
     */
    where?: ProjectInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvites to fetch.
     */
    orderBy?: Enumerable<ProjectInviteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectInvites
    **/
    _count?: true | ProjectInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectInviteMaxAggregateInputType
  }

  export type GetProjectInviteAggregateType<T extends ProjectInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectInvite[P]>
      : GetScalarType<T[P], AggregateProjectInvite[P]>
  }




  export type ProjectInviteGroupByArgs = {
    where?: ProjectInviteWhereInput
    orderBy?: Enumerable<ProjectInviteOrderByWithAggregationInput>
    by: ProjectInviteScalarFieldEnum[]
    having?: ProjectInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectInviteCountAggregateInputType | true
    _min?: ProjectInviteMinAggregateInputType
    _max?: ProjectInviteMaxAggregateInputType
  }


  export type ProjectInviteGroupByOutputType = {
    email: string
    expires: Date
    projectId: string
    createdAt: Date
    _count: ProjectInviteCountAggregateOutputType | null
    _min: ProjectInviteMinAggregateOutputType | null
    _max: ProjectInviteMaxAggregateOutputType | null
  }

  type GetProjectInviteGroupByPayload<T extends ProjectInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProjectInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectInviteGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectInviteGroupByOutputType[P]>
        }
      >
    >


  export type ProjectInviteSelect = {
    email?: boolean
    expires?: boolean
    projectId?: boolean
    createdAt?: boolean
    project?: boolean | ProjectArgs
  }


  export type ProjectInviteInclude = {
    project?: boolean | ProjectArgs
  }

  export type ProjectInviteGetPayload<S extends boolean | null | undefined | ProjectInviteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectInvite :
    S extends undefined ? never :
    S extends { include: any } & (ProjectInviteArgs | ProjectInviteFindManyArgs)
    ? ProjectInvite  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectInviteArgs | ProjectInviteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof ProjectInvite ? ProjectInvite[P] : never
  } 
      : ProjectInvite


  type ProjectInviteCountArgs = 
    Omit<ProjectInviteFindManyArgs, 'select' | 'include'> & {
      select?: ProjectInviteCountAggregateInputType | true
    }

  export interface ProjectInviteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProjectInvite that matches the filter.
     * @param {ProjectInviteFindUniqueArgs} args - Arguments to find a ProjectInvite
     * @example
     * // Get one ProjectInvite
     * const projectInvite = await prisma.projectInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectInviteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectInviteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectInvite'> extends True ? Prisma__ProjectInviteClient<ProjectInviteGetPayload<T>> : Prisma__ProjectInviteClient<ProjectInviteGetPayload<T> | null, null>

    /**
     * Find one ProjectInvite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectInviteFindUniqueOrThrowArgs} args - Arguments to find a ProjectInvite
     * @example
     * // Get one ProjectInvite
     * const projectInvite = await prisma.projectInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectInviteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectInviteFindUniqueOrThrowArgs>
    ): Prisma__ProjectInviteClient<ProjectInviteGetPayload<T>>

    /**
     * Find the first ProjectInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteFindFirstArgs} args - Arguments to find a ProjectInvite
     * @example
     * // Get one ProjectInvite
     * const projectInvite = await prisma.projectInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectInviteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectInviteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectInvite'> extends True ? Prisma__ProjectInviteClient<ProjectInviteGetPayload<T>> : Prisma__ProjectInviteClient<ProjectInviteGetPayload<T> | null, null>

    /**
     * Find the first ProjectInvite that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteFindFirstOrThrowArgs} args - Arguments to find a ProjectInvite
     * @example
     * // Get one ProjectInvite
     * const projectInvite = await prisma.projectInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectInviteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectInviteFindFirstOrThrowArgs>
    ): Prisma__ProjectInviteClient<ProjectInviteGetPayload<T>>

    /**
     * Find zero or more ProjectInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectInvites
     * const projectInvites = await prisma.projectInvite.findMany()
     * 
     * // Get first 10 ProjectInvites
     * const projectInvites = await prisma.projectInvite.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const projectInviteWithEmailOnly = await prisma.projectInvite.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends ProjectInviteFindManyArgs>(
      args?: SelectSubset<T, ProjectInviteFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProjectInviteGetPayload<T>>>

    /**
     * Create a ProjectInvite.
     * @param {ProjectInviteCreateArgs} args - Arguments to create a ProjectInvite.
     * @example
     * // Create one ProjectInvite
     * const ProjectInvite = await prisma.projectInvite.create({
     *   data: {
     *     // ... data to create a ProjectInvite
     *   }
     * })
     * 
    **/
    create<T extends ProjectInviteCreateArgs>(
      args: SelectSubset<T, ProjectInviteCreateArgs>
    ): Prisma__ProjectInviteClient<ProjectInviteGetPayload<T>>

    /**
     * Create many ProjectInvites.
     *     @param {ProjectInviteCreateManyArgs} args - Arguments to create many ProjectInvites.
     *     @example
     *     // Create many ProjectInvites
     *     const projectInvite = await prisma.projectInvite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectInviteCreateManyArgs>(
      args?: SelectSubset<T, ProjectInviteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectInvite.
     * @param {ProjectInviteDeleteArgs} args - Arguments to delete one ProjectInvite.
     * @example
     * // Delete one ProjectInvite
     * const ProjectInvite = await prisma.projectInvite.delete({
     *   where: {
     *     // ... filter to delete one ProjectInvite
     *   }
     * })
     * 
    **/
    delete<T extends ProjectInviteDeleteArgs>(
      args: SelectSubset<T, ProjectInviteDeleteArgs>
    ): Prisma__ProjectInviteClient<ProjectInviteGetPayload<T>>

    /**
     * Update one ProjectInvite.
     * @param {ProjectInviteUpdateArgs} args - Arguments to update one ProjectInvite.
     * @example
     * // Update one ProjectInvite
     * const projectInvite = await prisma.projectInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectInviteUpdateArgs>(
      args: SelectSubset<T, ProjectInviteUpdateArgs>
    ): Prisma__ProjectInviteClient<ProjectInviteGetPayload<T>>

    /**
     * Delete zero or more ProjectInvites.
     * @param {ProjectInviteDeleteManyArgs} args - Arguments to filter ProjectInvites to delete.
     * @example
     * // Delete a few ProjectInvites
     * const { count } = await prisma.projectInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectInviteDeleteManyArgs>(
      args?: SelectSubset<T, ProjectInviteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectInvites
     * const projectInvite = await prisma.projectInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectInviteUpdateManyArgs>(
      args: SelectSubset<T, ProjectInviteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectInvite.
     * @param {ProjectInviteUpsertArgs} args - Arguments to update or create a ProjectInvite.
     * @example
     * // Update or create a ProjectInvite
     * const projectInvite = await prisma.projectInvite.upsert({
     *   create: {
     *     // ... data to create a ProjectInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectInvite we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectInviteUpsertArgs>(
      args: SelectSubset<T, ProjectInviteUpsertArgs>
    ): Prisma__ProjectInviteClient<ProjectInviteGetPayload<T>>

    /**
     * Count the number of ProjectInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteCountArgs} args - Arguments to filter ProjectInvites to count.
     * @example
     * // Count the number of ProjectInvites
     * const count = await prisma.projectInvite.count({
     *   where: {
     *     // ... the filter for the ProjectInvites we want to count
     *   }
     * })
    **/
    count<T extends ProjectInviteCountArgs>(
      args?: Subset<T, ProjectInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectInviteAggregateArgs>(args: Subset<T, ProjectInviteAggregateArgs>): Prisma.PrismaPromise<GetProjectInviteAggregateType<T>>

    /**
     * Group by ProjectInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectInviteGroupByArgs['orderBy'] }
        : { orderBy?: ProjectInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectInviteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProjectInvite base type for findUnique actions
   */
  export type ProjectInviteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * Filter, which ProjectInvite to fetch.
     */
    where: ProjectInviteWhereUniqueInput
  }

  /**
   * ProjectInvite findUnique
   */
  export interface ProjectInviteFindUniqueArgs extends ProjectInviteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectInvite findUniqueOrThrow
   */
  export type ProjectInviteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * Filter, which ProjectInvite to fetch.
     */
    where: ProjectInviteWhereUniqueInput
  }


  /**
   * ProjectInvite base type for findFirst actions
   */
  export type ProjectInviteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * Filter, which ProjectInvite to fetch.
     */
    where?: ProjectInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvites to fetch.
     */
    orderBy?: Enumerable<ProjectInviteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectInvites.
     */
    cursor?: ProjectInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectInvites.
     */
    distinct?: Enumerable<ProjectInviteScalarFieldEnum>
  }

  /**
   * ProjectInvite findFirst
   */
  export interface ProjectInviteFindFirstArgs extends ProjectInviteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectInvite findFirstOrThrow
   */
  export type ProjectInviteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * Filter, which ProjectInvite to fetch.
     */
    where?: ProjectInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvites to fetch.
     */
    orderBy?: Enumerable<ProjectInviteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectInvites.
     */
    cursor?: ProjectInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectInvites.
     */
    distinct?: Enumerable<ProjectInviteScalarFieldEnum>
  }


  /**
   * ProjectInvite findMany
   */
  export type ProjectInviteFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * Filter, which ProjectInvites to fetch.
     */
    where?: ProjectInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvites to fetch.
     */
    orderBy?: Enumerable<ProjectInviteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectInvites.
     */
    cursor?: ProjectInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvites.
     */
    skip?: number
    distinct?: Enumerable<ProjectInviteScalarFieldEnum>
  }


  /**
   * ProjectInvite create
   */
  export type ProjectInviteCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * The data needed to create a ProjectInvite.
     */
    data: XOR<ProjectInviteCreateInput, ProjectInviteUncheckedCreateInput>
  }


  /**
   * ProjectInvite createMany
   */
  export type ProjectInviteCreateManyArgs = {
    /**
     * The data used to create many ProjectInvites.
     */
    data: Enumerable<ProjectInviteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProjectInvite update
   */
  export type ProjectInviteUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * The data needed to update a ProjectInvite.
     */
    data: XOR<ProjectInviteUpdateInput, ProjectInviteUncheckedUpdateInput>
    /**
     * Choose, which ProjectInvite to update.
     */
    where: ProjectInviteWhereUniqueInput
  }


  /**
   * ProjectInvite updateMany
   */
  export type ProjectInviteUpdateManyArgs = {
    /**
     * The data used to update ProjectInvites.
     */
    data: XOR<ProjectInviteUpdateManyMutationInput, ProjectInviteUncheckedUpdateManyInput>
    /**
     * Filter which ProjectInvites to update
     */
    where?: ProjectInviteWhereInput
  }


  /**
   * ProjectInvite upsert
   */
  export type ProjectInviteUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * The filter to search for the ProjectInvite to update in case it exists.
     */
    where: ProjectInviteWhereUniqueInput
    /**
     * In case the ProjectInvite found by the `where` argument doesn't exist, create a new ProjectInvite with this data.
     */
    create: XOR<ProjectInviteCreateInput, ProjectInviteUncheckedCreateInput>
    /**
     * In case the ProjectInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectInviteUpdateInput, ProjectInviteUncheckedUpdateInput>
  }


  /**
   * ProjectInvite delete
   */
  export type ProjectInviteDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
    /**
     * Filter which ProjectInvite to delete.
     */
    where: ProjectInviteWhereUniqueInput
  }


  /**
   * ProjectInvite deleteMany
   */
  export type ProjectInviteDeleteManyArgs = {
    /**
     * Filter which ProjectInvites to delete
     */
    where?: ProjectInviteWhereInput
  }


  /**
   * ProjectInvite without action
   */
  export type ProjectInviteArgs = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectInviteInclude | null
  }



  /**
   * Model ProjectUsers
   */


  export type AggregateProjectUsers = {
    _count: ProjectUsersCountAggregateOutputType | null
    _min: ProjectUsersMinAggregateOutputType | null
    _max: ProjectUsersMaxAggregateOutputType | null
  }

  export type ProjectUsersMinAggregateOutputType = {
    id: string | null
    role: Role | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    projectId: string | null
  }

  export type ProjectUsersMaxAggregateOutputType = {
    id: string | null
    role: Role | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    projectId: string | null
  }

  export type ProjectUsersCountAggregateOutputType = {
    id: number
    role: number
    createdAt: number
    updatedAt: number
    userId: number
    projectId: number
    _all: number
  }


  export type ProjectUsersMinAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    projectId?: true
  }

  export type ProjectUsersMaxAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    projectId?: true
  }

  export type ProjectUsersCountAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    projectId?: true
    _all?: true
  }

  export type ProjectUsersAggregateArgs = {
    /**
     * Filter which ProjectUsers to aggregate.
     */
    where?: ProjectUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: Enumerable<ProjectUsersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectUsers
    **/
    _count?: true | ProjectUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectUsersMaxAggregateInputType
  }

  export type GetProjectUsersAggregateType<T extends ProjectUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectUsers[P]>
      : GetScalarType<T[P], AggregateProjectUsers[P]>
  }




  export type ProjectUsersGroupByArgs = {
    where?: ProjectUsersWhereInput
    orderBy?: Enumerable<ProjectUsersOrderByWithAggregationInput>
    by: ProjectUsersScalarFieldEnum[]
    having?: ProjectUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectUsersCountAggregateInputType | true
    _min?: ProjectUsersMinAggregateInputType
    _max?: ProjectUsersMaxAggregateInputType
  }


  export type ProjectUsersGroupByOutputType = {
    id: string
    role: Role
    createdAt: Date
    updatedAt: Date
    userId: string
    projectId: string
    _count: ProjectUsersCountAggregateOutputType | null
    _min: ProjectUsersMinAggregateOutputType | null
    _max: ProjectUsersMaxAggregateOutputType | null
  }

  type GetProjectUsersGroupByPayload<T extends ProjectUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProjectUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectUsersGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectUsersGroupByOutputType[P]>
        }
      >
    >


  export type ProjectUsersSelect = {
    id?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    projectId?: boolean
    user?: boolean | UserArgs
    project?: boolean | ProjectArgs
  }


  export type ProjectUsersInclude = {
    user?: boolean | UserArgs
    project?: boolean | ProjectArgs
  }

  export type ProjectUsersGetPayload<S extends boolean | null | undefined | ProjectUsersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProjectUsers :
    S extends undefined ? never :
    S extends { include: any } & (ProjectUsersArgs | ProjectUsersFindManyArgs)
    ? ProjectUsers  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProjectUsersArgs | ProjectUsersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :  P extends keyof ProjectUsers ? ProjectUsers[P] : never
  } 
      : ProjectUsers


  type ProjectUsersCountArgs = 
    Omit<ProjectUsersFindManyArgs, 'select' | 'include'> & {
      select?: ProjectUsersCountAggregateInputType | true
    }

  export interface ProjectUsersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProjectUsers that matches the filter.
     * @param {ProjectUsersFindUniqueArgs} args - Arguments to find a ProjectUsers
     * @example
     * // Get one ProjectUsers
     * const projectUsers = await prisma.projectUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectUsersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectUsersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectUsers'> extends True ? Prisma__ProjectUsersClient<ProjectUsersGetPayload<T>> : Prisma__ProjectUsersClient<ProjectUsersGetPayload<T> | null, null>

    /**
     * Find one ProjectUsers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProjectUsersFindUniqueOrThrowArgs} args - Arguments to find a ProjectUsers
     * @example
     * // Get one ProjectUsers
     * const projectUsers = await prisma.projectUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProjectUsersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProjectUsersFindUniqueOrThrowArgs>
    ): Prisma__ProjectUsersClient<ProjectUsersGetPayload<T>>

    /**
     * Find the first ProjectUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUsersFindFirstArgs} args - Arguments to find a ProjectUsers
     * @example
     * // Get one ProjectUsers
     * const projectUsers = await prisma.projectUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectUsersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectUsersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectUsers'> extends True ? Prisma__ProjectUsersClient<ProjectUsersGetPayload<T>> : Prisma__ProjectUsersClient<ProjectUsersGetPayload<T> | null, null>

    /**
     * Find the first ProjectUsers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUsersFindFirstOrThrowArgs} args - Arguments to find a ProjectUsers
     * @example
     * // Get one ProjectUsers
     * const projectUsers = await prisma.projectUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProjectUsersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProjectUsersFindFirstOrThrowArgs>
    ): Prisma__ProjectUsersClient<ProjectUsersGetPayload<T>>

    /**
     * Find zero or more ProjectUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectUsers
     * const projectUsers = await prisma.projectUsers.findMany()
     * 
     * // Get first 10 ProjectUsers
     * const projectUsers = await prisma.projectUsers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectUsersWithIdOnly = await prisma.projectUsers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectUsersFindManyArgs>(
      args?: SelectSubset<T, ProjectUsersFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProjectUsersGetPayload<T>>>

    /**
     * Create a ProjectUsers.
     * @param {ProjectUsersCreateArgs} args - Arguments to create a ProjectUsers.
     * @example
     * // Create one ProjectUsers
     * const ProjectUsers = await prisma.projectUsers.create({
     *   data: {
     *     // ... data to create a ProjectUsers
     *   }
     * })
     * 
    **/
    create<T extends ProjectUsersCreateArgs>(
      args: SelectSubset<T, ProjectUsersCreateArgs>
    ): Prisma__ProjectUsersClient<ProjectUsersGetPayload<T>>

    /**
     * Create many ProjectUsers.
     *     @param {ProjectUsersCreateManyArgs} args - Arguments to create many ProjectUsers.
     *     @example
     *     // Create many ProjectUsers
     *     const projectUsers = await prisma.projectUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectUsersCreateManyArgs>(
      args?: SelectSubset<T, ProjectUsersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectUsers.
     * @param {ProjectUsersDeleteArgs} args - Arguments to delete one ProjectUsers.
     * @example
     * // Delete one ProjectUsers
     * const ProjectUsers = await prisma.projectUsers.delete({
     *   where: {
     *     // ... filter to delete one ProjectUsers
     *   }
     * })
     * 
    **/
    delete<T extends ProjectUsersDeleteArgs>(
      args: SelectSubset<T, ProjectUsersDeleteArgs>
    ): Prisma__ProjectUsersClient<ProjectUsersGetPayload<T>>

    /**
     * Update one ProjectUsers.
     * @param {ProjectUsersUpdateArgs} args - Arguments to update one ProjectUsers.
     * @example
     * // Update one ProjectUsers
     * const projectUsers = await prisma.projectUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUsersUpdateArgs>(
      args: SelectSubset<T, ProjectUsersUpdateArgs>
    ): Prisma__ProjectUsersClient<ProjectUsersGetPayload<T>>

    /**
     * Delete zero or more ProjectUsers.
     * @param {ProjectUsersDeleteManyArgs} args - Arguments to filter ProjectUsers to delete.
     * @example
     * // Delete a few ProjectUsers
     * const { count } = await prisma.projectUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectUsersDeleteManyArgs>(
      args?: SelectSubset<T, ProjectUsersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectUsers
     * const projectUsers = await prisma.projectUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUsersUpdateManyArgs>(
      args: SelectSubset<T, ProjectUsersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectUsers.
     * @param {ProjectUsersUpsertArgs} args - Arguments to update or create a ProjectUsers.
     * @example
     * // Update or create a ProjectUsers
     * const projectUsers = await prisma.projectUsers.upsert({
     *   create: {
     *     // ... data to create a ProjectUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectUsers we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUsersUpsertArgs>(
      args: SelectSubset<T, ProjectUsersUpsertArgs>
    ): Prisma__ProjectUsersClient<ProjectUsersGetPayload<T>>

    /**
     * Count the number of ProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUsersCountArgs} args - Arguments to filter ProjectUsers to count.
     * @example
     * // Count the number of ProjectUsers
     * const count = await prisma.projectUsers.count({
     *   where: {
     *     // ... the filter for the ProjectUsers we want to count
     *   }
     * })
    **/
    count<T extends ProjectUsersCountArgs>(
      args?: Subset<T, ProjectUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectUsersAggregateArgs>(args: Subset<T, ProjectUsersAggregateArgs>): Prisma.PrismaPromise<GetProjectUsersAggregateType<T>>

    /**
     * Group by ProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectUsersGroupByArgs['orderBy'] }
        : { orderBy?: ProjectUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectUsersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProjectUsers base type for findUnique actions
   */
  export type ProjectUsersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * Filter, which ProjectUsers to fetch.
     */
    where: ProjectUsersWhereUniqueInput
  }

  /**
   * ProjectUsers findUnique
   */
  export interface ProjectUsersFindUniqueArgs extends ProjectUsersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectUsers findUniqueOrThrow
   */
  export type ProjectUsersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * Filter, which ProjectUsers to fetch.
     */
    where: ProjectUsersWhereUniqueInput
  }


  /**
   * ProjectUsers base type for findFirst actions
   */
  export type ProjectUsersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * Filter, which ProjectUsers to fetch.
     */
    where?: ProjectUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: Enumerable<ProjectUsersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUsers.
     */
    cursor?: ProjectUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUsers.
     */
    distinct?: Enumerable<ProjectUsersScalarFieldEnum>
  }

  /**
   * ProjectUsers findFirst
   */
  export interface ProjectUsersFindFirstArgs extends ProjectUsersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProjectUsers findFirstOrThrow
   */
  export type ProjectUsersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * Filter, which ProjectUsers to fetch.
     */
    where?: ProjectUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: Enumerable<ProjectUsersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUsers.
     */
    cursor?: ProjectUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUsers.
     */
    distinct?: Enumerable<ProjectUsersScalarFieldEnum>
  }


  /**
   * ProjectUsers findMany
   */
  export type ProjectUsersFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * Filter, which ProjectUsers to fetch.
     */
    where?: ProjectUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: Enumerable<ProjectUsersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectUsers.
     */
    cursor?: ProjectUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    distinct?: Enumerable<ProjectUsersScalarFieldEnum>
  }


  /**
   * ProjectUsers create
   */
  export type ProjectUsersCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * The data needed to create a ProjectUsers.
     */
    data: XOR<ProjectUsersCreateInput, ProjectUsersUncheckedCreateInput>
  }


  /**
   * ProjectUsers createMany
   */
  export type ProjectUsersCreateManyArgs = {
    /**
     * The data used to create many ProjectUsers.
     */
    data: Enumerable<ProjectUsersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProjectUsers update
   */
  export type ProjectUsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * The data needed to update a ProjectUsers.
     */
    data: XOR<ProjectUsersUpdateInput, ProjectUsersUncheckedUpdateInput>
    /**
     * Choose, which ProjectUsers to update.
     */
    where: ProjectUsersWhereUniqueInput
  }


  /**
   * ProjectUsers updateMany
   */
  export type ProjectUsersUpdateManyArgs = {
    /**
     * The data used to update ProjectUsers.
     */
    data: XOR<ProjectUsersUpdateManyMutationInput, ProjectUsersUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUsers to update
     */
    where?: ProjectUsersWhereInput
  }


  /**
   * ProjectUsers upsert
   */
  export type ProjectUsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * The filter to search for the ProjectUsers to update in case it exists.
     */
    where: ProjectUsersWhereUniqueInput
    /**
     * In case the ProjectUsers found by the `where` argument doesn't exist, create a new ProjectUsers with this data.
     */
    create: XOR<ProjectUsersCreateInput, ProjectUsersUncheckedCreateInput>
    /**
     * In case the ProjectUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUsersUpdateInput, ProjectUsersUncheckedUpdateInput>
  }


  /**
   * ProjectUsers delete
   */
  export type ProjectUsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
    /**
     * Filter which ProjectUsers to delete.
     */
    where: ProjectUsersWhereUniqueInput
  }


  /**
   * ProjectUsers deleteMany
   */
  export type ProjectUsersDeleteManyArgs = {
    /**
     * Filter which ProjectUsers to delete
     */
    where?: ProjectUsersWhereInput
  }


  /**
   * ProjectUsers without action
   */
  export type ProjectUsersArgs = {
    /**
     * Select specific fields to fetch from the ProjectUsers
     */
    select?: ProjectUsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProjectUsersInclude | null
  }



  /**
   * Model SentEmail
   */


  export type AggregateSentEmail = {
    _count: SentEmailCountAggregateOutputType | null
    _min: SentEmailMinAggregateOutputType | null
    _max: SentEmailMaxAggregateOutputType | null
  }

  export type SentEmailMinAggregateOutputType = {
    id: string | null
    type: EmailType | null
    createdAt: Date | null
    projectId: string | null
  }

  export type SentEmailMaxAggregateOutputType = {
    id: string | null
    type: EmailType | null
    createdAt: Date | null
    projectId: string | null
  }

  export type SentEmailCountAggregateOutputType = {
    id: number
    type: number
    createdAt: number
    projectId: number
    _all: number
  }


  export type SentEmailMinAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    projectId?: true
  }

  export type SentEmailMaxAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    projectId?: true
  }

  export type SentEmailCountAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    projectId?: true
    _all?: true
  }

  export type SentEmailAggregateArgs = {
    /**
     * Filter which SentEmail to aggregate.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: Enumerable<SentEmailOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SentEmails
    **/
    _count?: true | SentEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SentEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SentEmailMaxAggregateInputType
  }

  export type GetSentEmailAggregateType<T extends SentEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateSentEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSentEmail[P]>
      : GetScalarType<T[P], AggregateSentEmail[P]>
  }




  export type SentEmailGroupByArgs = {
    where?: SentEmailWhereInput
    orderBy?: Enumerable<SentEmailOrderByWithAggregationInput>
    by: SentEmailScalarFieldEnum[]
    having?: SentEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SentEmailCountAggregateInputType | true
    _min?: SentEmailMinAggregateInputType
    _max?: SentEmailMaxAggregateInputType
  }


  export type SentEmailGroupByOutputType = {
    id: string
    type: EmailType
    createdAt: Date
    projectId: string | null
    _count: SentEmailCountAggregateOutputType | null
    _min: SentEmailMinAggregateOutputType | null
    _max: SentEmailMaxAggregateOutputType | null
  }

  type GetSentEmailGroupByPayload<T extends SentEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SentEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SentEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SentEmailGroupByOutputType[P]>
            : GetScalarType<T[P], SentEmailGroupByOutputType[P]>
        }
      >
    >


  export type SentEmailSelect = {
    id?: boolean
    type?: boolean
    createdAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectArgs
  }


  export type SentEmailInclude = {
    project?: boolean | ProjectArgs
  }

  export type SentEmailGetPayload<S extends boolean | null | undefined | SentEmailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SentEmail :
    S extends undefined ? never :
    S extends { include: any } & (SentEmailArgs | SentEmailFindManyArgs)
    ? SentEmail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (SentEmailArgs | SentEmailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> | null :  P extends keyof SentEmail ? SentEmail[P] : never
  } 
      : SentEmail


  type SentEmailCountArgs = 
    Omit<SentEmailFindManyArgs, 'select' | 'include'> & {
      select?: SentEmailCountAggregateInputType | true
    }

  export interface SentEmailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SentEmail that matches the filter.
     * @param {SentEmailFindUniqueArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SentEmailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SentEmailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SentEmail'> extends True ? Prisma__SentEmailClient<SentEmailGetPayload<T>> : Prisma__SentEmailClient<SentEmailGetPayload<T> | null, null>

    /**
     * Find one SentEmail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SentEmailFindUniqueOrThrowArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SentEmailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SentEmailFindUniqueOrThrowArgs>
    ): Prisma__SentEmailClient<SentEmailGetPayload<T>>

    /**
     * Find the first SentEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindFirstArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SentEmailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SentEmailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SentEmail'> extends True ? Prisma__SentEmailClient<SentEmailGetPayload<T>> : Prisma__SentEmailClient<SentEmailGetPayload<T> | null, null>

    /**
     * Find the first SentEmail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindFirstOrThrowArgs} args - Arguments to find a SentEmail
     * @example
     * // Get one SentEmail
     * const sentEmail = await prisma.sentEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SentEmailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SentEmailFindFirstOrThrowArgs>
    ): Prisma__SentEmailClient<SentEmailGetPayload<T>>

    /**
     * Find zero or more SentEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SentEmails
     * const sentEmails = await prisma.sentEmail.findMany()
     * 
     * // Get first 10 SentEmails
     * const sentEmails = await prisma.sentEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sentEmailWithIdOnly = await prisma.sentEmail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SentEmailFindManyArgs>(
      args?: SelectSubset<T, SentEmailFindManyArgs>
    ): Prisma.PrismaPromise<Array<SentEmailGetPayload<T>>>

    /**
     * Create a SentEmail.
     * @param {SentEmailCreateArgs} args - Arguments to create a SentEmail.
     * @example
     * // Create one SentEmail
     * const SentEmail = await prisma.sentEmail.create({
     *   data: {
     *     // ... data to create a SentEmail
     *   }
     * })
     * 
    **/
    create<T extends SentEmailCreateArgs>(
      args: SelectSubset<T, SentEmailCreateArgs>
    ): Prisma__SentEmailClient<SentEmailGetPayload<T>>

    /**
     * Create many SentEmails.
     *     @param {SentEmailCreateManyArgs} args - Arguments to create many SentEmails.
     *     @example
     *     // Create many SentEmails
     *     const sentEmail = await prisma.sentEmail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SentEmailCreateManyArgs>(
      args?: SelectSubset<T, SentEmailCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SentEmail.
     * @param {SentEmailDeleteArgs} args - Arguments to delete one SentEmail.
     * @example
     * // Delete one SentEmail
     * const SentEmail = await prisma.sentEmail.delete({
     *   where: {
     *     // ... filter to delete one SentEmail
     *   }
     * })
     * 
    **/
    delete<T extends SentEmailDeleteArgs>(
      args: SelectSubset<T, SentEmailDeleteArgs>
    ): Prisma__SentEmailClient<SentEmailGetPayload<T>>

    /**
     * Update one SentEmail.
     * @param {SentEmailUpdateArgs} args - Arguments to update one SentEmail.
     * @example
     * // Update one SentEmail
     * const sentEmail = await prisma.sentEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SentEmailUpdateArgs>(
      args: SelectSubset<T, SentEmailUpdateArgs>
    ): Prisma__SentEmailClient<SentEmailGetPayload<T>>

    /**
     * Delete zero or more SentEmails.
     * @param {SentEmailDeleteManyArgs} args - Arguments to filter SentEmails to delete.
     * @example
     * // Delete a few SentEmails
     * const { count } = await prisma.sentEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SentEmailDeleteManyArgs>(
      args?: SelectSubset<T, SentEmailDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SentEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SentEmails
     * const sentEmail = await prisma.sentEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SentEmailUpdateManyArgs>(
      args: SelectSubset<T, SentEmailUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SentEmail.
     * @param {SentEmailUpsertArgs} args - Arguments to update or create a SentEmail.
     * @example
     * // Update or create a SentEmail
     * const sentEmail = await prisma.sentEmail.upsert({
     *   create: {
     *     // ... data to create a SentEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SentEmail we want to update
     *   }
     * })
    **/
    upsert<T extends SentEmailUpsertArgs>(
      args: SelectSubset<T, SentEmailUpsertArgs>
    ): Prisma__SentEmailClient<SentEmailGetPayload<T>>

    /**
     * Count the number of SentEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailCountArgs} args - Arguments to filter SentEmails to count.
     * @example
     * // Count the number of SentEmails
     * const count = await prisma.sentEmail.count({
     *   where: {
     *     // ... the filter for the SentEmails we want to count
     *   }
     * })
    **/
    count<T extends SentEmailCountArgs>(
      args?: Subset<T, SentEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SentEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SentEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SentEmailAggregateArgs>(args: Subset<T, SentEmailAggregateArgs>): Prisma.PrismaPromise<GetSentEmailAggregateType<T>>

    /**
     * Group by SentEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SentEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SentEmailGroupByArgs['orderBy'] }
        : { orderBy?: SentEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SentEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSentEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SentEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SentEmailClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SentEmail base type for findUnique actions
   */
  export type SentEmailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where: SentEmailWhereUniqueInput
  }

  /**
   * SentEmail findUnique
   */
  export interface SentEmailFindUniqueArgs extends SentEmailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SentEmail findUniqueOrThrow
   */
  export type SentEmailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where: SentEmailWhereUniqueInput
  }


  /**
   * SentEmail base type for findFirst actions
   */
  export type SentEmailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: Enumerable<SentEmailOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SentEmails.
     */
    distinct?: Enumerable<SentEmailScalarFieldEnum>
  }

  /**
   * SentEmail findFirst
   */
  export interface SentEmailFindFirstArgs extends SentEmailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SentEmail findFirstOrThrow
   */
  export type SentEmailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * Filter, which SentEmail to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: Enumerable<SentEmailOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SentEmails.
     */
    distinct?: Enumerable<SentEmailScalarFieldEnum>
  }


  /**
   * SentEmail findMany
   */
  export type SentEmailFindManyArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * Filter, which SentEmails to fetch.
     */
    where?: SentEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SentEmails to fetch.
     */
    orderBy?: Enumerable<SentEmailOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SentEmails.
     */
    cursor?: SentEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SentEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SentEmails.
     */
    skip?: number
    distinct?: Enumerable<SentEmailScalarFieldEnum>
  }


  /**
   * SentEmail create
   */
  export type SentEmailCreateArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * The data needed to create a SentEmail.
     */
    data: XOR<SentEmailCreateInput, SentEmailUncheckedCreateInput>
  }


  /**
   * SentEmail createMany
   */
  export type SentEmailCreateManyArgs = {
    /**
     * The data used to create many SentEmails.
     */
    data: Enumerable<SentEmailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SentEmail update
   */
  export type SentEmailUpdateArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * The data needed to update a SentEmail.
     */
    data: XOR<SentEmailUpdateInput, SentEmailUncheckedUpdateInput>
    /**
     * Choose, which SentEmail to update.
     */
    where: SentEmailWhereUniqueInput
  }


  /**
   * SentEmail updateMany
   */
  export type SentEmailUpdateManyArgs = {
    /**
     * The data used to update SentEmails.
     */
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyInput>
    /**
     * Filter which SentEmails to update
     */
    where?: SentEmailWhereInput
  }


  /**
   * SentEmail upsert
   */
  export type SentEmailUpsertArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * The filter to search for the SentEmail to update in case it exists.
     */
    where: SentEmailWhereUniqueInput
    /**
     * In case the SentEmail found by the `where` argument doesn't exist, create a new SentEmail with this data.
     */
    create: XOR<SentEmailCreateInput, SentEmailUncheckedCreateInput>
    /**
     * In case the SentEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SentEmailUpdateInput, SentEmailUncheckedUpdateInput>
  }


  /**
   * SentEmail delete
   */
  export type SentEmailDeleteArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
    /**
     * Filter which SentEmail to delete.
     */
    where: SentEmailWhereUniqueInput
  }


  /**
   * SentEmail deleteMany
   */
  export type SentEmailDeleteManyArgs = {
    /**
     * Filter which SentEmails to delete
     */
    where?: SentEmailWhereInput
  }


  /**
   * SentEmail without action
   */
  export type SentEmailArgs = {
    /**
     * Select specific fields to fetch from the SentEmail
     */
    select?: SentEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentEmailInclude | null
  }



  /**
   * Model Domain
   */


  export type AggregateDomain = {
    _count: DomainCountAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  export type DomainMinAggregateOutputType = {
    id: string | null
    slug: string | null
    verified: boolean | null
    target: string | null
    type: string | null
    description: string | null
    projectId: string | null
    primary: boolean | null
    lastChecked: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    verified: boolean | null
    target: string | null
    type: string | null
    description: string | null
    projectId: string | null
    primary: boolean | null
    lastChecked: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainCountAggregateOutputType = {
    id: number
    slug: number
    verified: number
    target: number
    type: number
    description: number
    projectId: number
    primary: number
    lastChecked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainMinAggregateInputType = {
    id?: true
    slug?: true
    verified?: true
    target?: true
    type?: true
    description?: true
    projectId?: true
    primary?: true
    lastChecked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainMaxAggregateInputType = {
    id?: true
    slug?: true
    verified?: true
    target?: true
    type?: true
    description?: true
    projectId?: true
    primary?: true
    lastChecked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainCountAggregateInputType = {
    id?: true
    slug?: true
    verified?: true
    target?: true
    type?: true
    description?: true
    projectId?: true
    primary?: true
    lastChecked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainAggregateArgs = {
    /**
     * Filter which Domain to aggregate.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: Enumerable<DomainOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Domains
    **/
    _count?: true | DomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMaxAggregateInputType
  }

  export type GetDomainAggregateType<T extends DomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomain[P]>
      : GetScalarType<T[P], AggregateDomain[P]>
  }




  export type DomainGroupByArgs = {
    where?: DomainWhereInput
    orderBy?: Enumerable<DomainOrderByWithAggregationInput>
    by: DomainScalarFieldEnum[]
    having?: DomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCountAggregateInputType | true
    _min?: DomainMinAggregateInputType
    _max?: DomainMaxAggregateInputType
  }


  export type DomainGroupByOutputType = {
    id: string
    slug: string
    verified: boolean
    target: string | null
    type: string
    description: string | null
    projectId: string | null
    primary: boolean
    lastChecked: Date
    createdAt: Date
    updatedAt: Date
    _count: DomainCountAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  type GetDomainGroupByPayload<T extends DomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainGroupByOutputType[P]>
            : GetScalarType<T[P], DomainGroupByOutputType[P]>
        }
      >
    >


  export type DomainSelect = {
    id?: boolean
    slug?: boolean
    verified?: boolean
    target?: boolean
    type?: boolean
    description?: boolean
    projectId?: boolean
    primary?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectArgs
    links?: boolean | Domain$linksArgs
    _count?: boolean | DomainCountOutputTypeArgs
  }


  export type DomainInclude = {
    project?: boolean | ProjectArgs
    links?: boolean | Domain$linksArgs
    _count?: boolean | DomainCountOutputTypeArgs
  }

  export type DomainGetPayload<S extends boolean | null | undefined | DomainArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Domain :
    S extends undefined ? never :
    S extends { include: any } & (DomainArgs | DomainFindManyArgs)
    ? Domain  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> | null :
        P extends 'links' ? Array < LinkGetPayload<S['include'][P]>>  :
        P extends '_count' ? DomainCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DomainArgs | DomainFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> | null :
        P extends 'links' ? Array < LinkGetPayload<S['select'][P]>>  :
        P extends '_count' ? DomainCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Domain ? Domain[P] : never
  } 
      : Domain


  type DomainCountArgs = 
    Omit<DomainFindManyArgs, 'select' | 'include'> & {
      select?: DomainCountAggregateInputType | true
    }

  export interface DomainDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Domain that matches the filter.
     * @param {DomainFindUniqueArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DomainFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DomainFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Domain'> extends True ? Prisma__DomainClient<DomainGetPayload<T>> : Prisma__DomainClient<DomainGetPayload<T> | null, null>

    /**
     * Find one Domain that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DomainFindUniqueOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DomainFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DomainFindUniqueOrThrowArgs>
    ): Prisma__DomainClient<DomainGetPayload<T>>

    /**
     * Find the first Domain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DomainFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DomainFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Domain'> extends True ? Prisma__DomainClient<DomainGetPayload<T>> : Prisma__DomainClient<DomainGetPayload<T> | null, null>

    /**
     * Find the first Domain that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DomainFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DomainFindFirstOrThrowArgs>
    ): Prisma__DomainClient<DomainGetPayload<T>>

    /**
     * Find zero or more Domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domains
     * const domains = await prisma.domain.findMany()
     * 
     * // Get first 10 Domains
     * const domains = await prisma.domain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainWithIdOnly = await prisma.domain.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DomainFindManyArgs>(
      args?: SelectSubset<T, DomainFindManyArgs>
    ): Prisma.PrismaPromise<Array<DomainGetPayload<T>>>

    /**
     * Create a Domain.
     * @param {DomainCreateArgs} args - Arguments to create a Domain.
     * @example
     * // Create one Domain
     * const Domain = await prisma.domain.create({
     *   data: {
     *     // ... data to create a Domain
     *   }
     * })
     * 
    **/
    create<T extends DomainCreateArgs>(
      args: SelectSubset<T, DomainCreateArgs>
    ): Prisma__DomainClient<DomainGetPayload<T>>

    /**
     * Create many Domains.
     *     @param {DomainCreateManyArgs} args - Arguments to create many Domains.
     *     @example
     *     // Create many Domains
     *     const domain = await prisma.domain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DomainCreateManyArgs>(
      args?: SelectSubset<T, DomainCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Domain.
     * @param {DomainDeleteArgs} args - Arguments to delete one Domain.
     * @example
     * // Delete one Domain
     * const Domain = await prisma.domain.delete({
     *   where: {
     *     // ... filter to delete one Domain
     *   }
     * })
     * 
    **/
    delete<T extends DomainDeleteArgs>(
      args: SelectSubset<T, DomainDeleteArgs>
    ): Prisma__DomainClient<DomainGetPayload<T>>

    /**
     * Update one Domain.
     * @param {DomainUpdateArgs} args - Arguments to update one Domain.
     * @example
     * // Update one Domain
     * const domain = await prisma.domain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DomainUpdateArgs>(
      args: SelectSubset<T, DomainUpdateArgs>
    ): Prisma__DomainClient<DomainGetPayload<T>>

    /**
     * Delete zero or more Domains.
     * @param {DomainDeleteManyArgs} args - Arguments to filter Domains to delete.
     * @example
     * // Delete a few Domains
     * const { count } = await prisma.domain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DomainDeleteManyArgs>(
      args?: SelectSubset<T, DomainDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DomainUpdateManyArgs>(
      args: SelectSubset<T, DomainUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Domain.
     * @param {DomainUpsertArgs} args - Arguments to update or create a Domain.
     * @example
     * // Update or create a Domain
     * const domain = await prisma.domain.upsert({
     *   create: {
     *     // ... data to create a Domain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domain we want to update
     *   }
     * })
    **/
    upsert<T extends DomainUpsertArgs>(
      args: SelectSubset<T, DomainUpsertArgs>
    ): Prisma__DomainClient<DomainGetPayload<T>>

    /**
     * Count the number of Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCountArgs} args - Arguments to filter Domains to count.
     * @example
     * // Count the number of Domains
     * const count = await prisma.domain.count({
     *   where: {
     *     // ... the filter for the Domains we want to count
     *   }
     * })
    **/
    count<T extends DomainCountArgs>(
      args?: Subset<T, DomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAggregateArgs>(args: Subset<T, DomainAggregateArgs>): Prisma.PrismaPromise<GetDomainAggregateType<T>>

    /**
     * Group by Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainGroupByArgs['orderBy'] }
        : { orderBy?: DomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Domain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DomainClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    links<T extends Domain$linksArgs= {}>(args?: Subset<T, Domain$linksArgs>): Prisma.PrismaPromise<Array<LinkGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Domain base type for findUnique actions
   */
  export type DomainFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findUnique
   */
  export interface DomainFindUniqueArgs extends DomainFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Domain findUniqueOrThrow
   */
  export type DomainFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }


  /**
   * Domain base type for findFirst actions
   */
  export type DomainFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: Enumerable<DomainOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: Enumerable<DomainScalarFieldEnum>
  }

  /**
   * Domain findFirst
   */
  export interface DomainFindFirstArgs extends DomainFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Domain findFirstOrThrow
   */
  export type DomainFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: Enumerable<DomainOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: Enumerable<DomainScalarFieldEnum>
  }


  /**
   * Domain findMany
   */
  export type DomainFindManyArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * Filter, which Domains to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: Enumerable<DomainOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    distinct?: Enumerable<DomainScalarFieldEnum>
  }


  /**
   * Domain create
   */
  export type DomainCreateArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * The data needed to create a Domain.
     */
    data: XOR<DomainCreateInput, DomainUncheckedCreateInput>
  }


  /**
   * Domain createMany
   */
  export type DomainCreateManyArgs = {
    /**
     * The data used to create many Domains.
     */
    data: Enumerable<DomainCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Domain update
   */
  export type DomainUpdateArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * The data needed to update a Domain.
     */
    data: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
    /**
     * Choose, which Domain to update.
     */
    where: DomainWhereUniqueInput
  }


  /**
   * Domain updateMany
   */
  export type DomainUpdateManyArgs = {
    /**
     * The data used to update Domains.
     */
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyInput>
    /**
     * Filter which Domains to update
     */
    where?: DomainWhereInput
  }


  /**
   * Domain upsert
   */
  export type DomainUpsertArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * The filter to search for the Domain to update in case it exists.
     */
    where: DomainWhereUniqueInput
    /**
     * In case the Domain found by the `where` argument doesn't exist, create a new Domain with this data.
     */
    create: XOR<DomainCreateInput, DomainUncheckedCreateInput>
    /**
     * In case the Domain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
  }


  /**
   * Domain delete
   */
  export type DomainDeleteArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
    /**
     * Filter which Domain to delete.
     */
    where: DomainWhereUniqueInput
  }


  /**
   * Domain deleteMany
   */
  export type DomainDeleteManyArgs = {
    /**
     * Filter which Domains to delete
     */
    where?: DomainWhereInput
  }


  /**
   * Domain.links
   */
  export type Domain$linksArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    where?: LinkWhereInput
    orderBy?: Enumerable<LinkOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * Domain without action
   */
  export type DomainArgs = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainInclude | null
  }



  /**
   * Model Link
   */


  export type AggregateLink = {
    _count: LinkCountAggregateOutputType | null
    _avg: LinkAvgAggregateOutputType | null
    _sum: LinkSumAggregateOutputType | null
    _min: LinkMinAggregateOutputType | null
    _max: LinkMaxAggregateOutputType | null
  }

  export type LinkAvgAggregateOutputType = {
    clicks: number | null
  }

  export type LinkSumAggregateOutputType = {
    clicks: number | null
  }

  export type LinkMinAggregateOutputType = {
    id: string | null
    domain: string | null
    key: string | null
    url: string | null
    archived: boolean | null
    expiresAt: Date | null
    password: string | null
    proxy: boolean | null
    title: string | null
    description: string | null
    image: string | null
    utm_source: string | null
    utm_medium: string | null
    utm_campaign: string | null
    utm_term: string | null
    utm_content: string | null
    rewrite: boolean | null
    ios: string | null
    android: string | null
    userId: string | null
    projectId: string | null
    clicks: number | null
    publicStats: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    tagId: string | null
  }

  export type LinkMaxAggregateOutputType = {
    id: string | null
    domain: string | null
    key: string | null
    url: string | null
    archived: boolean | null
    expiresAt: Date | null
    password: string | null
    proxy: boolean | null
    title: string | null
    description: string | null
    image: string | null
    utm_source: string | null
    utm_medium: string | null
    utm_campaign: string | null
    utm_term: string | null
    utm_content: string | null
    rewrite: boolean | null
    ios: string | null
    android: string | null
    userId: string | null
    projectId: string | null
    clicks: number | null
    publicStats: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    tagId: string | null
  }

  export type LinkCountAggregateOutputType = {
    id: number
    domain: number
    key: number
    url: number
    archived: number
    expiresAt: number
    password: number
    proxy: number
    title: number
    description: number
    image: number
    utm_source: number
    utm_medium: number
    utm_campaign: number
    utm_term: number
    utm_content: number
    rewrite: number
    ios: number
    android: number
    userId: number
    projectId: number
    clicks: number
    publicStats: number
    createdAt: number
    updatedAt: number
    tagId: number
    _all: number
  }


  export type LinkAvgAggregateInputType = {
    clicks?: true
  }

  export type LinkSumAggregateInputType = {
    clicks?: true
  }

  export type LinkMinAggregateInputType = {
    id?: true
    domain?: true
    key?: true
    url?: true
    archived?: true
    expiresAt?: true
    password?: true
    proxy?: true
    title?: true
    description?: true
    image?: true
    utm_source?: true
    utm_medium?: true
    utm_campaign?: true
    utm_term?: true
    utm_content?: true
    rewrite?: true
    ios?: true
    android?: true
    userId?: true
    projectId?: true
    clicks?: true
    publicStats?: true
    createdAt?: true
    updatedAt?: true
    tagId?: true
  }

  export type LinkMaxAggregateInputType = {
    id?: true
    domain?: true
    key?: true
    url?: true
    archived?: true
    expiresAt?: true
    password?: true
    proxy?: true
    title?: true
    description?: true
    image?: true
    utm_source?: true
    utm_medium?: true
    utm_campaign?: true
    utm_term?: true
    utm_content?: true
    rewrite?: true
    ios?: true
    android?: true
    userId?: true
    projectId?: true
    clicks?: true
    publicStats?: true
    createdAt?: true
    updatedAt?: true
    tagId?: true
  }

  export type LinkCountAggregateInputType = {
    id?: true
    domain?: true
    key?: true
    url?: true
    archived?: true
    expiresAt?: true
    password?: true
    proxy?: true
    title?: true
    description?: true
    image?: true
    utm_source?: true
    utm_medium?: true
    utm_campaign?: true
    utm_term?: true
    utm_content?: true
    rewrite?: true
    ios?: true
    android?: true
    userId?: true
    projectId?: true
    clicks?: true
    publicStats?: true
    createdAt?: true
    updatedAt?: true
    tagId?: true
    _all?: true
  }

  export type LinkAggregateArgs = {
    /**
     * Filter which Link to aggregate.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: Enumerable<LinkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Links
    **/
    _count?: true | LinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkMaxAggregateInputType
  }

  export type GetLinkAggregateType<T extends LinkAggregateArgs> = {
        [P in keyof T & keyof AggregateLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLink[P]>
      : GetScalarType<T[P], AggregateLink[P]>
  }




  export type LinkGroupByArgs = {
    where?: LinkWhereInput
    orderBy?: Enumerable<LinkOrderByWithAggregationInput>
    by: LinkScalarFieldEnum[]
    having?: LinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkCountAggregateInputType | true
    _avg?: LinkAvgAggregateInputType
    _sum?: LinkSumAggregateInputType
    _min?: LinkMinAggregateInputType
    _max?: LinkMaxAggregateInputType
  }


  export type LinkGroupByOutputType = {
    id: string
    domain: string
    key: string
    url: string
    archived: boolean
    expiresAt: Date | null
    password: string | null
    proxy: boolean
    title: string | null
    description: string | null
    image: string | null
    utm_source: string | null
    utm_medium: string | null
    utm_campaign: string | null
    utm_term: string | null
    utm_content: string | null
    rewrite: boolean
    ios: string | null
    android: string | null
    userId: string | null
    projectId: string | null
    clicks: number
    publicStats: boolean
    createdAt: Date
    updatedAt: Date
    tagId: string | null
    _count: LinkCountAggregateOutputType | null
    _avg: LinkAvgAggregateOutputType | null
    _sum: LinkSumAggregateOutputType | null
    _min: LinkMinAggregateOutputType | null
    _max: LinkMaxAggregateOutputType | null
  }

  type GetLinkGroupByPayload<T extends LinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkGroupByOutputType[P]>
            : GetScalarType<T[P], LinkGroupByOutputType[P]>
        }
      >
    >


  export type LinkSelect = {
    id?: boolean
    domain?: boolean
    key?: boolean
    url?: boolean
    archived?: boolean
    expiresAt?: boolean
    password?: boolean
    proxy?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    utm_source?: boolean
    utm_medium?: boolean
    utm_campaign?: boolean
    utm_term?: boolean
    utm_content?: boolean
    rewrite?: boolean
    ios?: boolean
    android?: boolean
    userId?: boolean
    projectId?: boolean
    clicks?: boolean
    publicStats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tagId?: boolean
    user?: boolean | UserArgs
    project?: boolean | ProjectArgs
    projectDomain?: boolean | DomainArgs
    tag?: boolean | TagArgs
  }


  export type LinkInclude = {
    user?: boolean | UserArgs
    project?: boolean | ProjectArgs
    projectDomain?: boolean | DomainArgs
    tag?: boolean | TagArgs
  }

  export type LinkGetPayload<S extends boolean | null | undefined | LinkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Link :
    S extends undefined ? never :
    S extends { include: any } & (LinkArgs | LinkFindManyArgs)
    ? Link  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'project' ? ProjectGetPayload<S['include'][P]> | null :
        P extends 'projectDomain' ? DomainGetPayload<S['include'][P]> | null :
        P extends 'tag' ? TagGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (LinkArgs | LinkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'project' ? ProjectGetPayload<S['select'][P]> | null :
        P extends 'projectDomain' ? DomainGetPayload<S['select'][P]> | null :
        P extends 'tag' ? TagGetPayload<S['select'][P]> | null :  P extends keyof Link ? Link[P] : never
  } 
      : Link


  type LinkCountArgs = 
    Omit<LinkFindManyArgs, 'select' | 'include'> & {
      select?: LinkCountAggregateInputType | true
    }

  export interface LinkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Link that matches the filter.
     * @param {LinkFindUniqueArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LinkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LinkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Link'> extends True ? Prisma__LinkClient<LinkGetPayload<T>> : Prisma__LinkClient<LinkGetPayload<T> | null, null>

    /**
     * Find one Link that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LinkFindUniqueOrThrowArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LinkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LinkFindUniqueOrThrowArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Find the first Link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindFirstArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LinkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LinkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Link'> extends True ? Prisma__LinkClient<LinkGetPayload<T>> : Prisma__LinkClient<LinkGetPayload<T> | null, null>

    /**
     * Find the first Link that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindFirstOrThrowArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LinkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LinkFindFirstOrThrowArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Find zero or more Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Links
     * const links = await prisma.link.findMany()
     * 
     * // Get first 10 Links
     * const links = await prisma.link.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkWithIdOnly = await prisma.link.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LinkFindManyArgs>(
      args?: SelectSubset<T, LinkFindManyArgs>
    ): Prisma.PrismaPromise<Array<LinkGetPayload<T>>>

    /**
     * Create a Link.
     * @param {LinkCreateArgs} args - Arguments to create a Link.
     * @example
     * // Create one Link
     * const Link = await prisma.link.create({
     *   data: {
     *     // ... data to create a Link
     *   }
     * })
     * 
    **/
    create<T extends LinkCreateArgs>(
      args: SelectSubset<T, LinkCreateArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Create many Links.
     *     @param {LinkCreateManyArgs} args - Arguments to create many Links.
     *     @example
     *     // Create many Links
     *     const link = await prisma.link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LinkCreateManyArgs>(
      args?: SelectSubset<T, LinkCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Link.
     * @param {LinkDeleteArgs} args - Arguments to delete one Link.
     * @example
     * // Delete one Link
     * const Link = await prisma.link.delete({
     *   where: {
     *     // ... filter to delete one Link
     *   }
     * })
     * 
    **/
    delete<T extends LinkDeleteArgs>(
      args: SelectSubset<T, LinkDeleteArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Update one Link.
     * @param {LinkUpdateArgs} args - Arguments to update one Link.
     * @example
     * // Update one Link
     * const link = await prisma.link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LinkUpdateArgs>(
      args: SelectSubset<T, LinkUpdateArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Delete zero or more Links.
     * @param {LinkDeleteManyArgs} args - Arguments to filter Links to delete.
     * @example
     * // Delete a few Links
     * const { count } = await prisma.link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LinkDeleteManyArgs>(
      args?: SelectSubset<T, LinkDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Links
     * const link = await prisma.link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LinkUpdateManyArgs>(
      args: SelectSubset<T, LinkUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Link.
     * @param {LinkUpsertArgs} args - Arguments to update or create a Link.
     * @example
     * // Update or create a Link
     * const link = await prisma.link.upsert({
     *   create: {
     *     // ... data to create a Link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Link we want to update
     *   }
     * })
    **/
    upsert<T extends LinkUpsertArgs>(
      args: SelectSubset<T, LinkUpsertArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Count the number of Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkCountArgs} args - Arguments to filter Links to count.
     * @example
     * // Count the number of Links
     * const count = await prisma.link.count({
     *   where: {
     *     // ... the filter for the Links we want to count
     *   }
     * })
    **/
    count<T extends LinkCountArgs>(
      args?: Subset<T, LinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkAggregateArgs>(args: Subset<T, LinkAggregateArgs>): Prisma.PrismaPromise<GetLinkAggregateType<T>>

    /**
     * Group by Link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkGroupByArgs['orderBy'] }
        : { orderBy?: LinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LinkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    projectDomain<T extends DomainArgs= {}>(args?: Subset<T, DomainArgs>): Prisma__DomainClient<DomainGetPayload<T> | Null>;

    tag<T extends TagArgs= {}>(args?: Subset<T, TagArgs>): Prisma__TagClient<TagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Link base type for findUnique actions
   */
  export type LinkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Link to fetch.
     */
    where: LinkWhereUniqueInput
  }

  /**
   * Link findUnique
   */
  export interface LinkFindUniqueArgs extends LinkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Link findUniqueOrThrow
   */
  export type LinkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Link to fetch.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link base type for findFirst actions
   */
  export type LinkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Link to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: Enumerable<LinkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Links.
     */
    distinct?: Enumerable<LinkScalarFieldEnum>
  }

  /**
   * Link findFirst
   */
  export interface LinkFindFirstArgs extends LinkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Link findFirstOrThrow
   */
  export type LinkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Link to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: Enumerable<LinkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Links.
     */
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * Link findMany
   */
  export type LinkFindManyArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Links to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: Enumerable<LinkOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * Link create
   */
  export type LinkCreateArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * The data needed to create a Link.
     */
    data: XOR<LinkCreateInput, LinkUncheckedCreateInput>
  }


  /**
   * Link createMany
   */
  export type LinkCreateManyArgs = {
    /**
     * The data used to create many Links.
     */
    data: Enumerable<LinkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Link update
   */
  export type LinkUpdateArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * The data needed to update a Link.
     */
    data: XOR<LinkUpdateInput, LinkUncheckedUpdateInput>
    /**
     * Choose, which Link to update.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link updateMany
   */
  export type LinkUpdateManyArgs = {
    /**
     * The data used to update Links.
     */
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyInput>
    /**
     * Filter which Links to update
     */
    where?: LinkWhereInput
  }


  /**
   * Link upsert
   */
  export type LinkUpsertArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * The filter to search for the Link to update in case it exists.
     */
    where: LinkWhereUniqueInput
    /**
     * In case the Link found by the `where` argument doesn't exist, create a new Link with this data.
     */
    create: XOR<LinkCreateInput, LinkUncheckedCreateInput>
    /**
     * In case the Link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkUpdateInput, LinkUncheckedUpdateInput>
  }


  /**
   * Link delete
   */
  export type LinkDeleteArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter which Link to delete.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link deleteMany
   */
  export type LinkDeleteManyArgs = {
    /**
     * Filter which Links to delete
     */
    where?: LinkWhereInput
  }


  /**
   * Link without action
   */
  export type LinkArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
  }



  /**
   * Model Tag
   */


  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type TagAggregateArgs = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs = {
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithAggregationInput>
    by: TagScalarFieldEnum[]
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }


  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect = {
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectArgs
    links?: boolean | Tag$linksArgs
    _count?: boolean | TagCountOutputTypeArgs
  }


  export type TagInclude = {
    project?: boolean | ProjectArgs
    links?: boolean | Tag$linksArgs
    _count?: boolean | TagCountOutputTypeArgs
  }

  export type TagGetPayload<S extends boolean | null | undefined | TagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tag :
    S extends undefined ? never :
    S extends { include: any } & (TagArgs | TagFindManyArgs)
    ? Tag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'project' ? ProjectGetPayload<S['include'][P]> :
        P extends 'links' ? Array < LinkGetPayload<S['include'][P]>>  :
        P extends '_count' ? TagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TagArgs | TagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'project' ? ProjectGetPayload<S['select'][P]> :
        P extends 'links' ? Array < LinkGetPayload<S['select'][P]>>  :
        P extends '_count' ? TagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Tag ? Tag[P] : never
  } 
      : Tag


  type TagCountArgs = 
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tag'> extends True ? Prisma__TagClient<TagGetPayload<T>> : Prisma__TagClient<TagGetPayload<T> | null, null>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tag'> extends True ? Prisma__TagClient<TagGetPayload<T>> : Prisma__TagClient<TagGetPayload<T> | null, null>

    /**
     * Find the first Tag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs>(
      args?: SelectSubset<T, TagFindManyArgs>
    ): Prisma.PrismaPromise<Array<TagGetPayload<T>>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs>(
      args: SelectSubset<T, TagCreateArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs>(
      args?: SelectSubset<T, TagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs>(
      args: SelectSubset<T, TagDeleteArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs>(
      args: SelectSubset<T, TagUpdateArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs>(
      args?: SelectSubset<T, TagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs>(
      args: SelectSubset<T, TagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs>(
      args: SelectSubset<T, TagUpsertArgs>
    ): Prisma__TagClient<TagGetPayload<T>>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    project<T extends ProjectArgs= {}>(args?: Subset<T, ProjectArgs>): Prisma__ProjectClient<ProjectGetPayload<T> | Null>;

    links<T extends Tag$linksArgs= {}>(args?: Subset<T, Tag$linksArgs>): Prisma.PrismaPromise<Array<LinkGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tag base type for findUnique actions
   */
  export type TagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUnique
   */
  export interface TagFindUniqueArgs extends TagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag base type for findFirst actions
   */
  export type TagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: Enumerable<TagScalarFieldEnum>
  }

  /**
   * Tag findFirst
   */
  export interface TagFindFirstArgs extends TagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: Enumerable<TagOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag create
   */
  export type TagCreateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs = {
    /**
     * The data used to create many Tags.
     */
    data: Enumerable<TagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }


  /**
   * Tag.links
   */
  export type Tag$linksArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    where?: LinkWhereInput
    orderBy?: Enumerable<LinkOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * Tag without action
   */
  export type TagArgs = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude | null
  }



  /**
   * Model jackson_index
   */


  export type AggregateJackson_index = {
    _count: Jackson_indexCountAggregateOutputType | null
    _avg: Jackson_indexAvgAggregateOutputType | null
    _sum: Jackson_indexSumAggregateOutputType | null
    _min: Jackson_indexMinAggregateOutputType | null
    _max: Jackson_indexMaxAggregateOutputType | null
  }

  export type Jackson_indexAvgAggregateOutputType = {
    id: number | null
  }

  export type Jackson_indexSumAggregateOutputType = {
    id: number | null
  }

  export type Jackson_indexMinAggregateOutputType = {
    id: number | null
    key: string | null
    storeKey: string | null
  }

  export type Jackson_indexMaxAggregateOutputType = {
    id: number | null
    key: string | null
    storeKey: string | null
  }

  export type Jackson_indexCountAggregateOutputType = {
    id: number
    key: number
    storeKey: number
    _all: number
  }


  export type Jackson_indexAvgAggregateInputType = {
    id?: true
  }

  export type Jackson_indexSumAggregateInputType = {
    id?: true
  }

  export type Jackson_indexMinAggregateInputType = {
    id?: true
    key?: true
    storeKey?: true
  }

  export type Jackson_indexMaxAggregateInputType = {
    id?: true
    key?: true
    storeKey?: true
  }

  export type Jackson_indexCountAggregateInputType = {
    id?: true
    key?: true
    storeKey?: true
    _all?: true
  }

  export type Jackson_indexAggregateArgs = {
    /**
     * Filter which jackson_index to aggregate.
     */
    where?: jackson_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_indices to fetch.
     */
    orderBy?: Enumerable<jackson_indexOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jackson_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jackson_indices
    **/
    _count?: true | Jackson_indexCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Jackson_indexAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Jackson_indexSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Jackson_indexMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Jackson_indexMaxAggregateInputType
  }

  export type GetJackson_indexAggregateType<T extends Jackson_indexAggregateArgs> = {
        [P in keyof T & keyof AggregateJackson_index]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJackson_index[P]>
      : GetScalarType<T[P], AggregateJackson_index[P]>
  }




  export type Jackson_indexGroupByArgs = {
    where?: jackson_indexWhereInput
    orderBy?: Enumerable<jackson_indexOrderByWithAggregationInput>
    by: Jackson_indexScalarFieldEnum[]
    having?: jackson_indexScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Jackson_indexCountAggregateInputType | true
    _avg?: Jackson_indexAvgAggregateInputType
    _sum?: Jackson_indexSumAggregateInputType
    _min?: Jackson_indexMinAggregateInputType
    _max?: Jackson_indexMaxAggregateInputType
  }


  export type Jackson_indexGroupByOutputType = {
    id: number
    key: string
    storeKey: string
    _count: Jackson_indexCountAggregateOutputType | null
    _avg: Jackson_indexAvgAggregateOutputType | null
    _sum: Jackson_indexSumAggregateOutputType | null
    _min: Jackson_indexMinAggregateOutputType | null
    _max: Jackson_indexMaxAggregateOutputType | null
  }

  type GetJackson_indexGroupByPayload<T extends Jackson_indexGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Jackson_indexGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Jackson_indexGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Jackson_indexGroupByOutputType[P]>
            : GetScalarType<T[P], Jackson_indexGroupByOutputType[P]>
        }
      >
    >


  export type jackson_indexSelect = {
    id?: boolean
    key?: boolean
    storeKey?: boolean
  }


  export type jackson_indexGetPayload<S extends boolean | null | undefined | jackson_indexArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? jackson_index :
    S extends undefined ? never :
    S extends { include: any } & (jackson_indexArgs | jackson_indexFindManyArgs)
    ? jackson_index 
    : S extends { select: any } & (jackson_indexArgs | jackson_indexFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof jackson_index ? jackson_index[P] : never
  } 
      : jackson_index


  type jackson_indexCountArgs = 
    Omit<jackson_indexFindManyArgs, 'select' | 'include'> & {
      select?: Jackson_indexCountAggregateInputType | true
    }

  export interface jackson_indexDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Jackson_index that matches the filter.
     * @param {jackson_indexFindUniqueArgs} args - Arguments to find a Jackson_index
     * @example
     * // Get one Jackson_index
     * const jackson_index = await prisma.jackson_index.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends jackson_indexFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, jackson_indexFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'jackson_index'> extends True ? Prisma__jackson_indexClient<jackson_indexGetPayload<T>> : Prisma__jackson_indexClient<jackson_indexGetPayload<T> | null, null>

    /**
     * Find one Jackson_index that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {jackson_indexFindUniqueOrThrowArgs} args - Arguments to find a Jackson_index
     * @example
     * // Get one Jackson_index
     * const jackson_index = await prisma.jackson_index.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends jackson_indexFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, jackson_indexFindUniqueOrThrowArgs>
    ): Prisma__jackson_indexClient<jackson_indexGetPayload<T>>

    /**
     * Find the first Jackson_index that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_indexFindFirstArgs} args - Arguments to find a Jackson_index
     * @example
     * // Get one Jackson_index
     * const jackson_index = await prisma.jackson_index.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends jackson_indexFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, jackson_indexFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'jackson_index'> extends True ? Prisma__jackson_indexClient<jackson_indexGetPayload<T>> : Prisma__jackson_indexClient<jackson_indexGetPayload<T> | null, null>

    /**
     * Find the first Jackson_index that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_indexFindFirstOrThrowArgs} args - Arguments to find a Jackson_index
     * @example
     * // Get one Jackson_index
     * const jackson_index = await prisma.jackson_index.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends jackson_indexFindFirstOrThrowArgs>(
      args?: SelectSubset<T, jackson_indexFindFirstOrThrowArgs>
    ): Prisma__jackson_indexClient<jackson_indexGetPayload<T>>

    /**
     * Find zero or more Jackson_indices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_indexFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jackson_indices
     * const jackson_indices = await prisma.jackson_index.findMany()
     * 
     * // Get first 10 Jackson_indices
     * const jackson_indices = await prisma.jackson_index.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jackson_indexWithIdOnly = await prisma.jackson_index.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends jackson_indexFindManyArgs>(
      args?: SelectSubset<T, jackson_indexFindManyArgs>
    ): Prisma.PrismaPromise<Array<jackson_indexGetPayload<T>>>

    /**
     * Create a Jackson_index.
     * @param {jackson_indexCreateArgs} args - Arguments to create a Jackson_index.
     * @example
     * // Create one Jackson_index
     * const Jackson_index = await prisma.jackson_index.create({
     *   data: {
     *     // ... data to create a Jackson_index
     *   }
     * })
     * 
    **/
    create<T extends jackson_indexCreateArgs>(
      args: SelectSubset<T, jackson_indexCreateArgs>
    ): Prisma__jackson_indexClient<jackson_indexGetPayload<T>>

    /**
     * Create many Jackson_indices.
     *     @param {jackson_indexCreateManyArgs} args - Arguments to create many Jackson_indices.
     *     @example
     *     // Create many Jackson_indices
     *     const jackson_index = await prisma.jackson_index.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends jackson_indexCreateManyArgs>(
      args?: SelectSubset<T, jackson_indexCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jackson_index.
     * @param {jackson_indexDeleteArgs} args - Arguments to delete one Jackson_index.
     * @example
     * // Delete one Jackson_index
     * const Jackson_index = await prisma.jackson_index.delete({
     *   where: {
     *     // ... filter to delete one Jackson_index
     *   }
     * })
     * 
    **/
    delete<T extends jackson_indexDeleteArgs>(
      args: SelectSubset<T, jackson_indexDeleteArgs>
    ): Prisma__jackson_indexClient<jackson_indexGetPayload<T>>

    /**
     * Update one Jackson_index.
     * @param {jackson_indexUpdateArgs} args - Arguments to update one Jackson_index.
     * @example
     * // Update one Jackson_index
     * const jackson_index = await prisma.jackson_index.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends jackson_indexUpdateArgs>(
      args: SelectSubset<T, jackson_indexUpdateArgs>
    ): Prisma__jackson_indexClient<jackson_indexGetPayload<T>>

    /**
     * Delete zero or more Jackson_indices.
     * @param {jackson_indexDeleteManyArgs} args - Arguments to filter Jackson_indices to delete.
     * @example
     * // Delete a few Jackson_indices
     * const { count } = await prisma.jackson_index.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends jackson_indexDeleteManyArgs>(
      args?: SelectSubset<T, jackson_indexDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jackson_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_indexUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jackson_indices
     * const jackson_index = await prisma.jackson_index.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends jackson_indexUpdateManyArgs>(
      args: SelectSubset<T, jackson_indexUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jackson_index.
     * @param {jackson_indexUpsertArgs} args - Arguments to update or create a Jackson_index.
     * @example
     * // Update or create a Jackson_index
     * const jackson_index = await prisma.jackson_index.upsert({
     *   create: {
     *     // ... data to create a Jackson_index
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jackson_index we want to update
     *   }
     * })
    **/
    upsert<T extends jackson_indexUpsertArgs>(
      args: SelectSubset<T, jackson_indexUpsertArgs>
    ): Prisma__jackson_indexClient<jackson_indexGetPayload<T>>

    /**
     * Count the number of Jackson_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_indexCountArgs} args - Arguments to filter Jackson_indices to count.
     * @example
     * // Count the number of Jackson_indices
     * const count = await prisma.jackson_index.count({
     *   where: {
     *     // ... the filter for the Jackson_indices we want to count
     *   }
     * })
    **/
    count<T extends jackson_indexCountArgs>(
      args?: Subset<T, jackson_indexCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Jackson_indexCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jackson_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Jackson_indexAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Jackson_indexAggregateArgs>(args: Subset<T, Jackson_indexAggregateArgs>): Prisma.PrismaPromise<GetJackson_indexAggregateType<T>>

    /**
     * Group by Jackson_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Jackson_indexGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Jackson_indexGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Jackson_indexGroupByArgs['orderBy'] }
        : { orderBy?: Jackson_indexGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Jackson_indexGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJackson_indexGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for jackson_index.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__jackson_indexClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * jackson_index base type for findUnique actions
   */
  export type jackson_indexFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * Filter, which jackson_index to fetch.
     */
    where: jackson_indexWhereUniqueInput
  }

  /**
   * jackson_index findUnique
   */
  export interface jackson_indexFindUniqueArgs extends jackson_indexFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * jackson_index findUniqueOrThrow
   */
  export type jackson_indexFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * Filter, which jackson_index to fetch.
     */
    where: jackson_indexWhereUniqueInput
  }


  /**
   * jackson_index base type for findFirst actions
   */
  export type jackson_indexFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * Filter, which jackson_index to fetch.
     */
    where?: jackson_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_indices to fetch.
     */
    orderBy?: Enumerable<jackson_indexOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jackson_indices.
     */
    cursor?: jackson_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jackson_indices.
     */
    distinct?: Enumerable<Jackson_indexScalarFieldEnum>
  }

  /**
   * jackson_index findFirst
   */
  export interface jackson_indexFindFirstArgs extends jackson_indexFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * jackson_index findFirstOrThrow
   */
  export type jackson_indexFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * Filter, which jackson_index to fetch.
     */
    where?: jackson_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_indices to fetch.
     */
    orderBy?: Enumerable<jackson_indexOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jackson_indices.
     */
    cursor?: jackson_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jackson_indices.
     */
    distinct?: Enumerable<Jackson_indexScalarFieldEnum>
  }


  /**
   * jackson_index findMany
   */
  export type jackson_indexFindManyArgs = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * Filter, which jackson_indices to fetch.
     */
    where?: jackson_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_indices to fetch.
     */
    orderBy?: Enumerable<jackson_indexOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jackson_indices.
     */
    cursor?: jackson_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_indices.
     */
    skip?: number
    distinct?: Enumerable<Jackson_indexScalarFieldEnum>
  }


  /**
   * jackson_index create
   */
  export type jackson_indexCreateArgs = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * The data needed to create a jackson_index.
     */
    data: XOR<jackson_indexCreateInput, jackson_indexUncheckedCreateInput>
  }


  /**
   * jackson_index createMany
   */
  export type jackson_indexCreateManyArgs = {
    /**
     * The data used to create many jackson_indices.
     */
    data: Enumerable<jackson_indexCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * jackson_index update
   */
  export type jackson_indexUpdateArgs = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * The data needed to update a jackson_index.
     */
    data: XOR<jackson_indexUpdateInput, jackson_indexUncheckedUpdateInput>
    /**
     * Choose, which jackson_index to update.
     */
    where: jackson_indexWhereUniqueInput
  }


  /**
   * jackson_index updateMany
   */
  export type jackson_indexUpdateManyArgs = {
    /**
     * The data used to update jackson_indices.
     */
    data: XOR<jackson_indexUpdateManyMutationInput, jackson_indexUncheckedUpdateManyInput>
    /**
     * Filter which jackson_indices to update
     */
    where?: jackson_indexWhereInput
  }


  /**
   * jackson_index upsert
   */
  export type jackson_indexUpsertArgs = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * The filter to search for the jackson_index to update in case it exists.
     */
    where: jackson_indexWhereUniqueInput
    /**
     * In case the jackson_index found by the `where` argument doesn't exist, create a new jackson_index with this data.
     */
    create: XOR<jackson_indexCreateInput, jackson_indexUncheckedCreateInput>
    /**
     * In case the jackson_index was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jackson_indexUpdateInput, jackson_indexUncheckedUpdateInput>
  }


  /**
   * jackson_index delete
   */
  export type jackson_indexDeleteArgs = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
    /**
     * Filter which jackson_index to delete.
     */
    where: jackson_indexWhereUniqueInput
  }


  /**
   * jackson_index deleteMany
   */
  export type jackson_indexDeleteManyArgs = {
    /**
     * Filter which jackson_indices to delete
     */
    where?: jackson_indexWhereInput
  }


  /**
   * jackson_index without action
   */
  export type jackson_indexArgs = {
    /**
     * Select specific fields to fetch from the jackson_index
     */
    select?: jackson_indexSelect | null
  }



  /**
   * Model jackson_store
   */


  export type AggregateJackson_store = {
    _count: Jackson_storeCountAggregateOutputType | null
    _min: Jackson_storeMinAggregateOutputType | null
    _max: Jackson_storeMaxAggregateOutputType | null
  }

  export type Jackson_storeMinAggregateOutputType = {
    key: string | null
    value: string | null
    iv: string | null
    tag: string | null
    createdAt: Date | null
    modifiedAt: Date | null
  }

  export type Jackson_storeMaxAggregateOutputType = {
    key: string | null
    value: string | null
    iv: string | null
    tag: string | null
    createdAt: Date | null
    modifiedAt: Date | null
  }

  export type Jackson_storeCountAggregateOutputType = {
    key: number
    value: number
    iv: number
    tag: number
    createdAt: number
    modifiedAt: number
    _all: number
  }


  export type Jackson_storeMinAggregateInputType = {
    key?: true
    value?: true
    iv?: true
    tag?: true
    createdAt?: true
    modifiedAt?: true
  }

  export type Jackson_storeMaxAggregateInputType = {
    key?: true
    value?: true
    iv?: true
    tag?: true
    createdAt?: true
    modifiedAt?: true
  }

  export type Jackson_storeCountAggregateInputType = {
    key?: true
    value?: true
    iv?: true
    tag?: true
    createdAt?: true
    modifiedAt?: true
    _all?: true
  }

  export type Jackson_storeAggregateArgs = {
    /**
     * Filter which jackson_store to aggregate.
     */
    where?: jackson_storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_stores to fetch.
     */
    orderBy?: Enumerable<jackson_storeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jackson_storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jackson_stores
    **/
    _count?: true | Jackson_storeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Jackson_storeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Jackson_storeMaxAggregateInputType
  }

  export type GetJackson_storeAggregateType<T extends Jackson_storeAggregateArgs> = {
        [P in keyof T & keyof AggregateJackson_store]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJackson_store[P]>
      : GetScalarType<T[P], AggregateJackson_store[P]>
  }




  export type Jackson_storeGroupByArgs = {
    where?: jackson_storeWhereInput
    orderBy?: Enumerable<jackson_storeOrderByWithAggregationInput>
    by: Jackson_storeScalarFieldEnum[]
    having?: jackson_storeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Jackson_storeCountAggregateInputType | true
    _min?: Jackson_storeMinAggregateInputType
    _max?: Jackson_storeMaxAggregateInputType
  }


  export type Jackson_storeGroupByOutputType = {
    key: string
    value: string
    iv: string | null
    tag: string | null
    createdAt: Date
    modifiedAt: Date | null
    _count: Jackson_storeCountAggregateOutputType | null
    _min: Jackson_storeMinAggregateOutputType | null
    _max: Jackson_storeMaxAggregateOutputType | null
  }

  type GetJackson_storeGroupByPayload<T extends Jackson_storeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Jackson_storeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Jackson_storeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Jackson_storeGroupByOutputType[P]>
            : GetScalarType<T[P], Jackson_storeGroupByOutputType[P]>
        }
      >
    >


  export type jackson_storeSelect = {
    key?: boolean
    value?: boolean
    iv?: boolean
    tag?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
  }


  export type jackson_storeGetPayload<S extends boolean | null | undefined | jackson_storeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? jackson_store :
    S extends undefined ? never :
    S extends { include: any } & (jackson_storeArgs | jackson_storeFindManyArgs)
    ? jackson_store 
    : S extends { select: any } & (jackson_storeArgs | jackson_storeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof jackson_store ? jackson_store[P] : never
  } 
      : jackson_store


  type jackson_storeCountArgs = 
    Omit<jackson_storeFindManyArgs, 'select' | 'include'> & {
      select?: Jackson_storeCountAggregateInputType | true
    }

  export interface jackson_storeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Jackson_store that matches the filter.
     * @param {jackson_storeFindUniqueArgs} args - Arguments to find a Jackson_store
     * @example
     * // Get one Jackson_store
     * const jackson_store = await prisma.jackson_store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends jackson_storeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, jackson_storeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'jackson_store'> extends True ? Prisma__jackson_storeClient<jackson_storeGetPayload<T>> : Prisma__jackson_storeClient<jackson_storeGetPayload<T> | null, null>

    /**
     * Find one Jackson_store that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {jackson_storeFindUniqueOrThrowArgs} args - Arguments to find a Jackson_store
     * @example
     * // Get one Jackson_store
     * const jackson_store = await prisma.jackson_store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends jackson_storeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, jackson_storeFindUniqueOrThrowArgs>
    ): Prisma__jackson_storeClient<jackson_storeGetPayload<T>>

    /**
     * Find the first Jackson_store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_storeFindFirstArgs} args - Arguments to find a Jackson_store
     * @example
     * // Get one Jackson_store
     * const jackson_store = await prisma.jackson_store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends jackson_storeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, jackson_storeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'jackson_store'> extends True ? Prisma__jackson_storeClient<jackson_storeGetPayload<T>> : Prisma__jackson_storeClient<jackson_storeGetPayload<T> | null, null>

    /**
     * Find the first Jackson_store that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_storeFindFirstOrThrowArgs} args - Arguments to find a Jackson_store
     * @example
     * // Get one Jackson_store
     * const jackson_store = await prisma.jackson_store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends jackson_storeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, jackson_storeFindFirstOrThrowArgs>
    ): Prisma__jackson_storeClient<jackson_storeGetPayload<T>>

    /**
     * Find zero or more Jackson_stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_storeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jackson_stores
     * const jackson_stores = await prisma.jackson_store.findMany()
     * 
     * // Get first 10 Jackson_stores
     * const jackson_stores = await prisma.jackson_store.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const jackson_storeWithKeyOnly = await prisma.jackson_store.findMany({ select: { key: true } })
     * 
    **/
    findMany<T extends jackson_storeFindManyArgs>(
      args?: SelectSubset<T, jackson_storeFindManyArgs>
    ): Prisma.PrismaPromise<Array<jackson_storeGetPayload<T>>>

    /**
     * Create a Jackson_store.
     * @param {jackson_storeCreateArgs} args - Arguments to create a Jackson_store.
     * @example
     * // Create one Jackson_store
     * const Jackson_store = await prisma.jackson_store.create({
     *   data: {
     *     // ... data to create a Jackson_store
     *   }
     * })
     * 
    **/
    create<T extends jackson_storeCreateArgs>(
      args: SelectSubset<T, jackson_storeCreateArgs>
    ): Prisma__jackson_storeClient<jackson_storeGetPayload<T>>

    /**
     * Create many Jackson_stores.
     *     @param {jackson_storeCreateManyArgs} args - Arguments to create many Jackson_stores.
     *     @example
     *     // Create many Jackson_stores
     *     const jackson_store = await prisma.jackson_store.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends jackson_storeCreateManyArgs>(
      args?: SelectSubset<T, jackson_storeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jackson_store.
     * @param {jackson_storeDeleteArgs} args - Arguments to delete one Jackson_store.
     * @example
     * // Delete one Jackson_store
     * const Jackson_store = await prisma.jackson_store.delete({
     *   where: {
     *     // ... filter to delete one Jackson_store
     *   }
     * })
     * 
    **/
    delete<T extends jackson_storeDeleteArgs>(
      args: SelectSubset<T, jackson_storeDeleteArgs>
    ): Prisma__jackson_storeClient<jackson_storeGetPayload<T>>

    /**
     * Update one Jackson_store.
     * @param {jackson_storeUpdateArgs} args - Arguments to update one Jackson_store.
     * @example
     * // Update one Jackson_store
     * const jackson_store = await prisma.jackson_store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends jackson_storeUpdateArgs>(
      args: SelectSubset<T, jackson_storeUpdateArgs>
    ): Prisma__jackson_storeClient<jackson_storeGetPayload<T>>

    /**
     * Delete zero or more Jackson_stores.
     * @param {jackson_storeDeleteManyArgs} args - Arguments to filter Jackson_stores to delete.
     * @example
     * // Delete a few Jackson_stores
     * const { count } = await prisma.jackson_store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends jackson_storeDeleteManyArgs>(
      args?: SelectSubset<T, jackson_storeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jackson_stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_storeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jackson_stores
     * const jackson_store = await prisma.jackson_store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends jackson_storeUpdateManyArgs>(
      args: SelectSubset<T, jackson_storeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jackson_store.
     * @param {jackson_storeUpsertArgs} args - Arguments to update or create a Jackson_store.
     * @example
     * // Update or create a Jackson_store
     * const jackson_store = await prisma.jackson_store.upsert({
     *   create: {
     *     // ... data to create a Jackson_store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jackson_store we want to update
     *   }
     * })
    **/
    upsert<T extends jackson_storeUpsertArgs>(
      args: SelectSubset<T, jackson_storeUpsertArgs>
    ): Prisma__jackson_storeClient<jackson_storeGetPayload<T>>

    /**
     * Count the number of Jackson_stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_storeCountArgs} args - Arguments to filter Jackson_stores to count.
     * @example
     * // Count the number of Jackson_stores
     * const count = await prisma.jackson_store.count({
     *   where: {
     *     // ... the filter for the Jackson_stores we want to count
     *   }
     * })
    **/
    count<T extends jackson_storeCountArgs>(
      args?: Subset<T, jackson_storeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Jackson_storeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jackson_store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Jackson_storeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Jackson_storeAggregateArgs>(args: Subset<T, Jackson_storeAggregateArgs>): Prisma.PrismaPromise<GetJackson_storeAggregateType<T>>

    /**
     * Group by Jackson_store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Jackson_storeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Jackson_storeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Jackson_storeGroupByArgs['orderBy'] }
        : { orderBy?: Jackson_storeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Jackson_storeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJackson_storeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for jackson_store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__jackson_storeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * jackson_store base type for findUnique actions
   */
  export type jackson_storeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * Filter, which jackson_store to fetch.
     */
    where: jackson_storeWhereUniqueInput
  }

  /**
   * jackson_store findUnique
   */
  export interface jackson_storeFindUniqueArgs extends jackson_storeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * jackson_store findUniqueOrThrow
   */
  export type jackson_storeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * Filter, which jackson_store to fetch.
     */
    where: jackson_storeWhereUniqueInput
  }


  /**
   * jackson_store base type for findFirst actions
   */
  export type jackson_storeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * Filter, which jackson_store to fetch.
     */
    where?: jackson_storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_stores to fetch.
     */
    orderBy?: Enumerable<jackson_storeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jackson_stores.
     */
    cursor?: jackson_storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jackson_stores.
     */
    distinct?: Enumerable<Jackson_storeScalarFieldEnum>
  }

  /**
   * jackson_store findFirst
   */
  export interface jackson_storeFindFirstArgs extends jackson_storeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * jackson_store findFirstOrThrow
   */
  export type jackson_storeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * Filter, which jackson_store to fetch.
     */
    where?: jackson_storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_stores to fetch.
     */
    orderBy?: Enumerable<jackson_storeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jackson_stores.
     */
    cursor?: jackson_storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jackson_stores.
     */
    distinct?: Enumerable<Jackson_storeScalarFieldEnum>
  }


  /**
   * jackson_store findMany
   */
  export type jackson_storeFindManyArgs = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * Filter, which jackson_stores to fetch.
     */
    where?: jackson_storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_stores to fetch.
     */
    orderBy?: Enumerable<jackson_storeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jackson_stores.
     */
    cursor?: jackson_storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_stores.
     */
    skip?: number
    distinct?: Enumerable<Jackson_storeScalarFieldEnum>
  }


  /**
   * jackson_store create
   */
  export type jackson_storeCreateArgs = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * The data needed to create a jackson_store.
     */
    data: XOR<jackson_storeCreateInput, jackson_storeUncheckedCreateInput>
  }


  /**
   * jackson_store createMany
   */
  export type jackson_storeCreateManyArgs = {
    /**
     * The data used to create many jackson_stores.
     */
    data: Enumerable<jackson_storeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * jackson_store update
   */
  export type jackson_storeUpdateArgs = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * The data needed to update a jackson_store.
     */
    data: XOR<jackson_storeUpdateInput, jackson_storeUncheckedUpdateInput>
    /**
     * Choose, which jackson_store to update.
     */
    where: jackson_storeWhereUniqueInput
  }


  /**
   * jackson_store updateMany
   */
  export type jackson_storeUpdateManyArgs = {
    /**
     * The data used to update jackson_stores.
     */
    data: XOR<jackson_storeUpdateManyMutationInput, jackson_storeUncheckedUpdateManyInput>
    /**
     * Filter which jackson_stores to update
     */
    where?: jackson_storeWhereInput
  }


  /**
   * jackson_store upsert
   */
  export type jackson_storeUpsertArgs = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * The filter to search for the jackson_store to update in case it exists.
     */
    where: jackson_storeWhereUniqueInput
    /**
     * In case the jackson_store found by the `where` argument doesn't exist, create a new jackson_store with this data.
     */
    create: XOR<jackson_storeCreateInput, jackson_storeUncheckedCreateInput>
    /**
     * In case the jackson_store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jackson_storeUpdateInput, jackson_storeUncheckedUpdateInput>
  }


  /**
   * jackson_store delete
   */
  export type jackson_storeDeleteArgs = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
    /**
     * Filter which jackson_store to delete.
     */
    where: jackson_storeWhereUniqueInput
  }


  /**
   * jackson_store deleteMany
   */
  export type jackson_storeDeleteManyArgs = {
    /**
     * Filter which jackson_stores to delete
     */
    where?: jackson_storeWhereInput
  }


  /**
   * jackson_store without action
   */
  export type jackson_storeArgs = {
    /**
     * Select specific fields to fetch from the jackson_store
     */
    select?: jackson_storeSelect | null
  }



  /**
   * Model jackson_ttl
   */


  export type AggregateJackson_ttl = {
    _count: Jackson_ttlCountAggregateOutputType | null
    _avg: Jackson_ttlAvgAggregateOutputType | null
    _sum: Jackson_ttlSumAggregateOutputType | null
    _min: Jackson_ttlMinAggregateOutputType | null
    _max: Jackson_ttlMaxAggregateOutputType | null
  }

  export type Jackson_ttlAvgAggregateOutputType = {
    expiresAt: number | null
  }

  export type Jackson_ttlSumAggregateOutputType = {
    expiresAt: bigint | null
  }

  export type Jackson_ttlMinAggregateOutputType = {
    key: string | null
    expiresAt: bigint | null
  }

  export type Jackson_ttlMaxAggregateOutputType = {
    key: string | null
    expiresAt: bigint | null
  }

  export type Jackson_ttlCountAggregateOutputType = {
    key: number
    expiresAt: number
    _all: number
  }


  export type Jackson_ttlAvgAggregateInputType = {
    expiresAt?: true
  }

  export type Jackson_ttlSumAggregateInputType = {
    expiresAt?: true
  }

  export type Jackson_ttlMinAggregateInputType = {
    key?: true
    expiresAt?: true
  }

  export type Jackson_ttlMaxAggregateInputType = {
    key?: true
    expiresAt?: true
  }

  export type Jackson_ttlCountAggregateInputType = {
    key?: true
    expiresAt?: true
    _all?: true
  }

  export type Jackson_ttlAggregateArgs = {
    /**
     * Filter which jackson_ttl to aggregate.
     */
    where?: jackson_ttlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_ttls to fetch.
     */
    orderBy?: Enumerable<jackson_ttlOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jackson_ttlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_ttls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_ttls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jackson_ttls
    **/
    _count?: true | Jackson_ttlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Jackson_ttlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Jackson_ttlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Jackson_ttlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Jackson_ttlMaxAggregateInputType
  }

  export type GetJackson_ttlAggregateType<T extends Jackson_ttlAggregateArgs> = {
        [P in keyof T & keyof AggregateJackson_ttl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJackson_ttl[P]>
      : GetScalarType<T[P], AggregateJackson_ttl[P]>
  }




  export type Jackson_ttlGroupByArgs = {
    where?: jackson_ttlWhereInput
    orderBy?: Enumerable<jackson_ttlOrderByWithAggregationInput>
    by: Jackson_ttlScalarFieldEnum[]
    having?: jackson_ttlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Jackson_ttlCountAggregateInputType | true
    _avg?: Jackson_ttlAvgAggregateInputType
    _sum?: Jackson_ttlSumAggregateInputType
    _min?: Jackson_ttlMinAggregateInputType
    _max?: Jackson_ttlMaxAggregateInputType
  }


  export type Jackson_ttlGroupByOutputType = {
    key: string
    expiresAt: bigint
    _count: Jackson_ttlCountAggregateOutputType | null
    _avg: Jackson_ttlAvgAggregateOutputType | null
    _sum: Jackson_ttlSumAggregateOutputType | null
    _min: Jackson_ttlMinAggregateOutputType | null
    _max: Jackson_ttlMaxAggregateOutputType | null
  }

  type GetJackson_ttlGroupByPayload<T extends Jackson_ttlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Jackson_ttlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Jackson_ttlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Jackson_ttlGroupByOutputType[P]>
            : GetScalarType<T[P], Jackson_ttlGroupByOutputType[P]>
        }
      >
    >


  export type jackson_ttlSelect = {
    key?: boolean
    expiresAt?: boolean
  }


  export type jackson_ttlGetPayload<S extends boolean | null | undefined | jackson_ttlArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? jackson_ttl :
    S extends undefined ? never :
    S extends { include: any } & (jackson_ttlArgs | jackson_ttlFindManyArgs)
    ? jackson_ttl 
    : S extends { select: any } & (jackson_ttlArgs | jackson_ttlFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof jackson_ttl ? jackson_ttl[P] : never
  } 
      : jackson_ttl


  type jackson_ttlCountArgs = 
    Omit<jackson_ttlFindManyArgs, 'select' | 'include'> & {
      select?: Jackson_ttlCountAggregateInputType | true
    }

  export interface jackson_ttlDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Jackson_ttl that matches the filter.
     * @param {jackson_ttlFindUniqueArgs} args - Arguments to find a Jackson_ttl
     * @example
     * // Get one Jackson_ttl
     * const jackson_ttl = await prisma.jackson_ttl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends jackson_ttlFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, jackson_ttlFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'jackson_ttl'> extends True ? Prisma__jackson_ttlClient<jackson_ttlGetPayload<T>> : Prisma__jackson_ttlClient<jackson_ttlGetPayload<T> | null, null>

    /**
     * Find one Jackson_ttl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {jackson_ttlFindUniqueOrThrowArgs} args - Arguments to find a Jackson_ttl
     * @example
     * // Get one Jackson_ttl
     * const jackson_ttl = await prisma.jackson_ttl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends jackson_ttlFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, jackson_ttlFindUniqueOrThrowArgs>
    ): Prisma__jackson_ttlClient<jackson_ttlGetPayload<T>>

    /**
     * Find the first Jackson_ttl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_ttlFindFirstArgs} args - Arguments to find a Jackson_ttl
     * @example
     * // Get one Jackson_ttl
     * const jackson_ttl = await prisma.jackson_ttl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends jackson_ttlFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, jackson_ttlFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'jackson_ttl'> extends True ? Prisma__jackson_ttlClient<jackson_ttlGetPayload<T>> : Prisma__jackson_ttlClient<jackson_ttlGetPayload<T> | null, null>

    /**
     * Find the first Jackson_ttl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_ttlFindFirstOrThrowArgs} args - Arguments to find a Jackson_ttl
     * @example
     * // Get one Jackson_ttl
     * const jackson_ttl = await prisma.jackson_ttl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends jackson_ttlFindFirstOrThrowArgs>(
      args?: SelectSubset<T, jackson_ttlFindFirstOrThrowArgs>
    ): Prisma__jackson_ttlClient<jackson_ttlGetPayload<T>>

    /**
     * Find zero or more Jackson_ttls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_ttlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jackson_ttls
     * const jackson_ttls = await prisma.jackson_ttl.findMany()
     * 
     * // Get first 10 Jackson_ttls
     * const jackson_ttls = await prisma.jackson_ttl.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const jackson_ttlWithKeyOnly = await prisma.jackson_ttl.findMany({ select: { key: true } })
     * 
    **/
    findMany<T extends jackson_ttlFindManyArgs>(
      args?: SelectSubset<T, jackson_ttlFindManyArgs>
    ): Prisma.PrismaPromise<Array<jackson_ttlGetPayload<T>>>

    /**
     * Create a Jackson_ttl.
     * @param {jackson_ttlCreateArgs} args - Arguments to create a Jackson_ttl.
     * @example
     * // Create one Jackson_ttl
     * const Jackson_ttl = await prisma.jackson_ttl.create({
     *   data: {
     *     // ... data to create a Jackson_ttl
     *   }
     * })
     * 
    **/
    create<T extends jackson_ttlCreateArgs>(
      args: SelectSubset<T, jackson_ttlCreateArgs>
    ): Prisma__jackson_ttlClient<jackson_ttlGetPayload<T>>

    /**
     * Create many Jackson_ttls.
     *     @param {jackson_ttlCreateManyArgs} args - Arguments to create many Jackson_ttls.
     *     @example
     *     // Create many Jackson_ttls
     *     const jackson_ttl = await prisma.jackson_ttl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends jackson_ttlCreateManyArgs>(
      args?: SelectSubset<T, jackson_ttlCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jackson_ttl.
     * @param {jackson_ttlDeleteArgs} args - Arguments to delete one Jackson_ttl.
     * @example
     * // Delete one Jackson_ttl
     * const Jackson_ttl = await prisma.jackson_ttl.delete({
     *   where: {
     *     // ... filter to delete one Jackson_ttl
     *   }
     * })
     * 
    **/
    delete<T extends jackson_ttlDeleteArgs>(
      args: SelectSubset<T, jackson_ttlDeleteArgs>
    ): Prisma__jackson_ttlClient<jackson_ttlGetPayload<T>>

    /**
     * Update one Jackson_ttl.
     * @param {jackson_ttlUpdateArgs} args - Arguments to update one Jackson_ttl.
     * @example
     * // Update one Jackson_ttl
     * const jackson_ttl = await prisma.jackson_ttl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends jackson_ttlUpdateArgs>(
      args: SelectSubset<T, jackson_ttlUpdateArgs>
    ): Prisma__jackson_ttlClient<jackson_ttlGetPayload<T>>

    /**
     * Delete zero or more Jackson_ttls.
     * @param {jackson_ttlDeleteManyArgs} args - Arguments to filter Jackson_ttls to delete.
     * @example
     * // Delete a few Jackson_ttls
     * const { count } = await prisma.jackson_ttl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends jackson_ttlDeleteManyArgs>(
      args?: SelectSubset<T, jackson_ttlDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jackson_ttls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_ttlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jackson_ttls
     * const jackson_ttl = await prisma.jackson_ttl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends jackson_ttlUpdateManyArgs>(
      args: SelectSubset<T, jackson_ttlUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jackson_ttl.
     * @param {jackson_ttlUpsertArgs} args - Arguments to update or create a Jackson_ttl.
     * @example
     * // Update or create a Jackson_ttl
     * const jackson_ttl = await prisma.jackson_ttl.upsert({
     *   create: {
     *     // ... data to create a Jackson_ttl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jackson_ttl we want to update
     *   }
     * })
    **/
    upsert<T extends jackson_ttlUpsertArgs>(
      args: SelectSubset<T, jackson_ttlUpsertArgs>
    ): Prisma__jackson_ttlClient<jackson_ttlGetPayload<T>>

    /**
     * Count the number of Jackson_ttls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jackson_ttlCountArgs} args - Arguments to filter Jackson_ttls to count.
     * @example
     * // Count the number of Jackson_ttls
     * const count = await prisma.jackson_ttl.count({
     *   where: {
     *     // ... the filter for the Jackson_ttls we want to count
     *   }
     * })
    **/
    count<T extends jackson_ttlCountArgs>(
      args?: Subset<T, jackson_ttlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Jackson_ttlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jackson_ttl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Jackson_ttlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Jackson_ttlAggregateArgs>(args: Subset<T, Jackson_ttlAggregateArgs>): Prisma.PrismaPromise<GetJackson_ttlAggregateType<T>>

    /**
     * Group by Jackson_ttl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Jackson_ttlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Jackson_ttlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Jackson_ttlGroupByArgs['orderBy'] }
        : { orderBy?: Jackson_ttlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Jackson_ttlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJackson_ttlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for jackson_ttl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__jackson_ttlClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * jackson_ttl base type for findUnique actions
   */
  export type jackson_ttlFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * Filter, which jackson_ttl to fetch.
     */
    where: jackson_ttlWhereUniqueInput
  }

  /**
   * jackson_ttl findUnique
   */
  export interface jackson_ttlFindUniqueArgs extends jackson_ttlFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * jackson_ttl findUniqueOrThrow
   */
  export type jackson_ttlFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * Filter, which jackson_ttl to fetch.
     */
    where: jackson_ttlWhereUniqueInput
  }


  /**
   * jackson_ttl base type for findFirst actions
   */
  export type jackson_ttlFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * Filter, which jackson_ttl to fetch.
     */
    where?: jackson_ttlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_ttls to fetch.
     */
    orderBy?: Enumerable<jackson_ttlOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jackson_ttls.
     */
    cursor?: jackson_ttlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_ttls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_ttls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jackson_ttls.
     */
    distinct?: Enumerable<Jackson_ttlScalarFieldEnum>
  }

  /**
   * jackson_ttl findFirst
   */
  export interface jackson_ttlFindFirstArgs extends jackson_ttlFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * jackson_ttl findFirstOrThrow
   */
  export type jackson_ttlFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * Filter, which jackson_ttl to fetch.
     */
    where?: jackson_ttlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_ttls to fetch.
     */
    orderBy?: Enumerable<jackson_ttlOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jackson_ttls.
     */
    cursor?: jackson_ttlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_ttls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_ttls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jackson_ttls.
     */
    distinct?: Enumerable<Jackson_ttlScalarFieldEnum>
  }


  /**
   * jackson_ttl findMany
   */
  export type jackson_ttlFindManyArgs = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * Filter, which jackson_ttls to fetch.
     */
    where?: jackson_ttlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jackson_ttls to fetch.
     */
    orderBy?: Enumerable<jackson_ttlOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jackson_ttls.
     */
    cursor?: jackson_ttlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jackson_ttls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jackson_ttls.
     */
    skip?: number
    distinct?: Enumerable<Jackson_ttlScalarFieldEnum>
  }


  /**
   * jackson_ttl create
   */
  export type jackson_ttlCreateArgs = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * The data needed to create a jackson_ttl.
     */
    data: XOR<jackson_ttlCreateInput, jackson_ttlUncheckedCreateInput>
  }


  /**
   * jackson_ttl createMany
   */
  export type jackson_ttlCreateManyArgs = {
    /**
     * The data used to create many jackson_ttls.
     */
    data: Enumerable<jackson_ttlCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * jackson_ttl update
   */
  export type jackson_ttlUpdateArgs = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * The data needed to update a jackson_ttl.
     */
    data: XOR<jackson_ttlUpdateInput, jackson_ttlUncheckedUpdateInput>
    /**
     * Choose, which jackson_ttl to update.
     */
    where: jackson_ttlWhereUniqueInput
  }


  /**
   * jackson_ttl updateMany
   */
  export type jackson_ttlUpdateManyArgs = {
    /**
     * The data used to update jackson_ttls.
     */
    data: XOR<jackson_ttlUpdateManyMutationInput, jackson_ttlUncheckedUpdateManyInput>
    /**
     * Filter which jackson_ttls to update
     */
    where?: jackson_ttlWhereInput
  }


  /**
   * jackson_ttl upsert
   */
  export type jackson_ttlUpsertArgs = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * The filter to search for the jackson_ttl to update in case it exists.
     */
    where: jackson_ttlWhereUniqueInput
    /**
     * In case the jackson_ttl found by the `where` argument doesn't exist, create a new jackson_ttl with this data.
     */
    create: XOR<jackson_ttlCreateInput, jackson_ttlUncheckedCreateInput>
    /**
     * In case the jackson_ttl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jackson_ttlUpdateInput, jackson_ttlUncheckedUpdateInput>
  }


  /**
   * jackson_ttl delete
   */
  export type jackson_ttlDeleteArgs = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
    /**
     * Filter which jackson_ttl to delete.
     */
    where: jackson_ttlWhereUniqueInput
  }


  /**
   * jackson_ttl deleteMany
   */
  export type jackson_ttlDeleteManyArgs = {
    /**
     * Filter which jackson_ttls to delete
     */
    where?: jackson_ttlWhereInput
  }


  /**
   * jackson_ttl without action
   */
  export type jackson_ttlArgs = {
    /**
     * Select specific fields to fetch from the jackson_ttl
     */
    select?: jackson_ttlSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    refresh_token_expires_in: 'refresh_token_expires_in',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AuditsOrderByRelevanceFieldEnum: {
    auditType: 'auditType',
    userId: 'userId',
    username: 'username',
    action: 'action',
    auditChanges: 'auditChanges'
  };

  export type AuditsOrderByRelevanceFieldEnum = (typeof AuditsOrderByRelevanceFieldEnum)[keyof typeof AuditsOrderByRelevanceFieldEnum]


  export const AuditsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    auditId: 'auditId',
    auditType: 'auditType',
    userId: 'userId',
    username: 'username',
    action: 'action',
    auditChanges: 'auditChanges',
    version: 'version'
  };

  export type AuditsScalarFieldEnum = (typeof AuditsScalarFieldEnum)[keyof typeof AuditsScalarFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    extendData: 'extendData'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const DomainOrderByRelevanceFieldEnum: {
    id: 'id',
    slug: 'slug',
    target: 'target',
    type: 'type',
    description: 'description',
    projectId: 'projectId'
  };

  export type DomainOrderByRelevanceFieldEnum = (typeof DomainOrderByRelevanceFieldEnum)[keyof typeof DomainOrderByRelevanceFieldEnum]


  export const DomainScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    verified: 'verified',
    target: 'target',
    type: 'type',
    description: 'description',
    projectId: 'projectId',
    primary: 'primary',
    lastChecked: 'lastChecked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


  export const Jackson_indexScalarFieldEnum: {
    id: 'id',
    key: 'key',
    storeKey: 'storeKey'
  };

  export type Jackson_indexScalarFieldEnum = (typeof Jackson_indexScalarFieldEnum)[keyof typeof Jackson_indexScalarFieldEnum]


  export const Jackson_storeScalarFieldEnum: {
    key: 'key',
    value: 'value',
    iv: 'iv',
    tag: 'tag',
    createdAt: 'createdAt',
    modifiedAt: 'modifiedAt'
  };

  export type Jackson_storeScalarFieldEnum = (typeof Jackson_storeScalarFieldEnum)[keyof typeof Jackson_storeScalarFieldEnum]


  export const Jackson_ttlScalarFieldEnum: {
    key: 'key',
    expiresAt: 'expiresAt'
  };

  export type Jackson_ttlScalarFieldEnum = (typeof Jackson_ttlScalarFieldEnum)[keyof typeof Jackson_ttlScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const LinkOrderByRelevanceFieldEnum: {
    id: 'id',
    domain: 'domain',
    key: 'key',
    url: 'url',
    password: 'password',
    title: 'title',
    description: 'description',
    image: 'image',
    utm_source: 'utm_source',
    utm_medium: 'utm_medium',
    utm_campaign: 'utm_campaign',
    utm_term: 'utm_term',
    utm_content: 'utm_content',
    ios: 'ios',
    android: 'android',
    userId: 'userId',
    projectId: 'projectId',
    tagId: 'tagId'
  };

  export type LinkOrderByRelevanceFieldEnum = (typeof LinkOrderByRelevanceFieldEnum)[keyof typeof LinkOrderByRelevanceFieldEnum]


  export const LinkScalarFieldEnum: {
    id: 'id',
    domain: 'domain',
    key: 'key',
    url: 'url',
    archived: 'archived',
    expiresAt: 'expiresAt',
    password: 'password',
    proxy: 'proxy',
    title: 'title',
    description: 'description',
    image: 'image',
    utm_source: 'utm_source',
    utm_medium: 'utm_medium',
    utm_campaign: 'utm_campaign',
    utm_term: 'utm_term',
    utm_content: 'utm_content',
    rewrite: 'rewrite',
    ios: 'ios',
    android: 'android',
    userId: 'userId',
    projectId: 'projectId',
    clicks: 'clicks',
    publicStats: 'publicStats',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tagId: 'tagId'
  };

  export type LinkScalarFieldEnum = (typeof LinkScalarFieldEnum)[keyof typeof LinkScalarFieldEnum]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const ProjectInviteOrderByRelevanceFieldEnum: {
    email: 'email',
    projectId: 'projectId'
  };

  export type ProjectInviteOrderByRelevanceFieldEnum = (typeof ProjectInviteOrderByRelevanceFieldEnum)[keyof typeof ProjectInviteOrderByRelevanceFieldEnum]


  export const ProjectInviteScalarFieldEnum: {
    email: 'email',
    expires: 'expires',
    projectId: 'projectId',
    createdAt: 'createdAt'
  };

  export type ProjectInviteScalarFieldEnum = (typeof ProjectInviteScalarFieldEnum)[keyof typeof ProjectInviteScalarFieldEnum]


  export const ProjectOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    password: 'password',
    type: 'type',
    plan: 'plan',
    stripeId: 'stripeId',
    region: 'region',
    endpoint: 'endpoint',
    bucket: 'bucket',
    useHost: 'useHost'
  };

  export type ProjectOrderByRelevanceFieldEnum = (typeof ProjectOrderByRelevanceFieldEnum)[keyof typeof ProjectOrderByRelevanceFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    password: 'password',
    type: 'type',
    usage: 'usage',
    usageLimit: 'usageLimit',
    plan: 'plan',
    stripeId: 'stripeId',
    billingCycleStart: 'billingCycleStart',
    region: 'region',
    endpoint: 'endpoint',
    bucket: 'bucket',
    useHost: 'useHost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectUsersOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectId: 'projectId'
  };

  export type ProjectUsersOrderByRelevanceFieldEnum = (typeof ProjectUsersOrderByRelevanceFieldEnum)[keyof typeof ProjectUsersOrderByRelevanceFieldEnum]


  export const ProjectUsersScalarFieldEnum: {
    id: 'id',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    projectId: 'projectId'
  };

  export type ProjectUsersScalarFieldEnum = (typeof ProjectUsersScalarFieldEnum)[keyof typeof ProjectUsersScalarFieldEnum]


  export const SentEmailOrderByRelevanceFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type SentEmailOrderByRelevanceFieldEnum = (typeof SentEmailOrderByRelevanceFieldEnum)[keyof typeof SentEmailOrderByRelevanceFieldEnum]


  export const SentEmailScalarFieldEnum: {
    id: 'id',
    type: 'type',
    createdAt: 'createdAt',
    projectId: 'projectId'
  };

  export type SentEmailScalarFieldEnum = (typeof SentEmailScalarFieldEnum)[keyof typeof SentEmailScalarFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SiteOrderByRelevanceFieldEnum: {
    name: 'name',
    cosUrl: 'cosUrl'
  };

  export type SiteOrderByRelevanceFieldEnum = (typeof SiteOrderByRelevanceFieldEnum)[keyof typeof SiteOrderByRelevanceFieldEnum]


  export const SiteScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    cosUrl: 'cosUrl',
    siteTemplateId: 'siteTemplateId',
    customerId: 'customerId',
    slotData: 'slotData'
  };

  export type SiteScalarFieldEnum = (typeof SiteScalarFieldEnum)[keyof typeof SiteScalarFieldEnum]


  export const SiteTemplateDataDefScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    siteTemplateId: 'siteTemplateId',
    defData: 'defData'
  };

  export type SiteTemplateDataDefScalarFieldEnum = (typeof SiteTemplateDataDefScalarFieldEnum)[keyof typeof SiteTemplateDataDefScalarFieldEnum]


  export const SiteTemplateOrderByRelevanceFieldEnum: {
    name: 'name',
    template: 'template'
  };

  export type SiteTemplateOrderByRelevanceFieldEnum = (typeof SiteTemplateOrderByRelevanceFieldEnum)[keyof typeof SiteTemplateOrderByRelevanceFieldEnum]


  export const SiteTemplateScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    template: 'template'
  };

  export type SiteTemplateScalarFieldEnum = (typeof SiteTemplateScalarFieldEnum)[keyof typeof SiteTemplateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TagOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    projectId: 'projectId'
  };

  export type TagOrderByRelevanceFieldEnum = (typeof TagOrderByRelevanceFieldEnum)[keyof typeof TagOrderByRelevanceFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    image: 'image'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    identifier: 'identifier',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const jackson_indexOrderByRelevanceFieldEnum: {
    key: 'key',
    storeKey: 'storeKey'
  };

  export type jackson_indexOrderByRelevanceFieldEnum = (typeof jackson_indexOrderByRelevanceFieldEnum)[keyof typeof jackson_indexOrderByRelevanceFieldEnum]


  export const jackson_storeOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value',
    iv: 'iv',
    tag: 'tag'
  };

  export type jackson_storeOrderByRelevanceFieldEnum = (typeof jackson_storeOrderByRelevanceFieldEnum)[keyof typeof jackson_storeOrderByRelevanceFieldEnum]


  export const jackson_ttlOrderByRelevanceFieldEnum: {
    key: 'key'
  };

  export type jackson_ttlOrderByRelevanceFieldEnum = (typeof jackson_ttlOrderByRelevanceFieldEnum)[keyof typeof jackson_ttlOrderByRelevanceFieldEnum]


  /**
   * Deep Input Types
   */


  export type AuditsWhereInput = {
    AND?: Enumerable<AuditsWhereInput>
    OR?: Enumerable<AuditsWhereInput>
    NOT?: Enumerable<AuditsWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    auditId?: IntFilter | number
    auditType?: StringFilter | string
    userId?: StringFilter | string
    username?: StringNullableFilter | string | null
    action?: StringFilter | string
    auditChanges?: StringFilter | string
    version?: IntFilter | number
  }

  export type AuditsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    auditId?: SortOrder
    auditType?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    action?: SortOrder
    auditChanges?: SortOrder
    version?: SortOrder
    _relevance?: AuditsOrderByRelevanceInput
  }

  export type AuditsWhereUniqueInput = {
    id?: number
  }

  export type AuditsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    auditId?: SortOrder
    auditType?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    action?: SortOrder
    auditChanges?: SortOrder
    version?: SortOrder
    _count?: AuditsCountOrderByAggregateInput
    _avg?: AuditsAvgOrderByAggregateInput
    _max?: AuditsMaxOrderByAggregateInput
    _min?: AuditsMinOrderByAggregateInput
    _sum?: AuditsSumOrderByAggregateInput
  }

  export type AuditsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuditsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuditsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuditsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    auditId?: IntWithAggregatesFilter | number
    auditType?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    action?: StringWithAggregatesFilter | string
    auditChanges?: StringWithAggregatesFilter | string
    version?: IntWithAggregatesFilter | number
  }

  export type SiteTemplateWhereInput = {
    AND?: Enumerable<SiteTemplateWhereInput>
    OR?: Enumerable<SiteTemplateWhereInput>
    NOT?: Enumerable<SiteTemplateWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    template?: StringFilter | string
    site?: SiteListRelationFilter
    siteTemplateDataDef?: XOR<SiteTemplateDataDefRelationFilter, SiteTemplateDataDefWhereInput> | null
  }

  export type SiteTemplateOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    template?: SortOrder
    site?: SiteOrderByRelationAggregateInput
    siteTemplateDataDef?: SiteTemplateDataDefOrderByWithRelationAndSearchRelevanceInput
    _relevance?: SiteTemplateOrderByRelevanceInput
  }

  export type SiteTemplateWhereUniqueInput = {
    id?: number
  }

  export type SiteTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    template?: SortOrder
    _count?: SiteTemplateCountOrderByAggregateInput
    _avg?: SiteTemplateAvgOrderByAggregateInput
    _max?: SiteTemplateMaxOrderByAggregateInput
    _min?: SiteTemplateMinOrderByAggregateInput
    _sum?: SiteTemplateSumOrderByAggregateInput
  }

  export type SiteTemplateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SiteTemplateScalarWhereWithAggregatesInput>
    OR?: Enumerable<SiteTemplateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SiteTemplateScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    template?: StringWithAggregatesFilter | string
  }

  export type SiteTemplateDataDefWhereInput = {
    AND?: Enumerable<SiteTemplateDataDefWhereInput>
    OR?: Enumerable<SiteTemplateDataDefWhereInput>
    NOT?: Enumerable<SiteTemplateDataDefWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    siteTemplateId?: IntFilter | number
    defData?: JsonFilter
    siteTemplate?: XOR<SiteTemplateRelationFilter, SiteTemplateWhereInput>
  }

  export type SiteTemplateDataDefOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    siteTemplateId?: SortOrder
    defData?: SortOrder
    siteTemplate?: SiteTemplateOrderByWithRelationAndSearchRelevanceInput
  }

  export type SiteTemplateDataDefWhereUniqueInput = {
    id?: number
    siteTemplateId?: number
  }

  export type SiteTemplateDataDefOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    siteTemplateId?: SortOrder
    defData?: SortOrder
    _count?: SiteTemplateDataDefCountOrderByAggregateInput
    _avg?: SiteTemplateDataDefAvgOrderByAggregateInput
    _max?: SiteTemplateDataDefMaxOrderByAggregateInput
    _min?: SiteTemplateDataDefMinOrderByAggregateInput
    _sum?: SiteTemplateDataDefSumOrderByAggregateInput
  }

  export type SiteTemplateDataDefScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SiteTemplateDataDefScalarWhereWithAggregatesInput>
    OR?: Enumerable<SiteTemplateDataDefScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SiteTemplateDataDefScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    siteTemplateId?: IntWithAggregatesFilter | number
    defData?: JsonWithAggregatesFilter
  }

  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    extendData?: JsonNullableFilter
    site?: SiteListRelationFilter
  }

  export type CustomerOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    extendData?: SortOrder
    site?: SiteOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = {
    id?: number
  }

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    extendData?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    extendData?: JsonNullableWithAggregatesFilter
  }

  export type SiteWhereInput = {
    AND?: Enumerable<SiteWhereInput>
    OR?: Enumerable<SiteWhereInput>
    NOT?: Enumerable<SiteWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    cosUrl?: StringFilter | string
    siteTemplateId?: IntFilter | number
    customerId?: IntFilter | number
    slotData?: JsonFilter
    siteTemplate?: XOR<SiteTemplateRelationFilter, SiteTemplateWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type SiteOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    cosUrl?: SortOrder
    siteTemplateId?: SortOrder
    customerId?: SortOrder
    slotData?: SortOrder
    siteTemplate?: SiteTemplateOrderByWithRelationAndSearchRelevanceInput
    customer?: CustomerOrderByWithRelationAndSearchRelevanceInput
    _relevance?: SiteOrderByRelevanceInput
  }

  export type SiteWhereUniqueInput = {
    id?: number
  }

  export type SiteOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    cosUrl?: SortOrder
    siteTemplateId?: SortOrder
    customerId?: SortOrder
    slotData?: SortOrder
    _count?: SiteCountOrderByAggregateInput
    _avg?: SiteAvgOrderByAggregateInput
    _max?: SiteMaxOrderByAggregateInput
    _min?: SiteMinOrderByAggregateInput
    _sum?: SiteSumOrderByAggregateInput
  }

  export type SiteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SiteScalarWhereWithAggregatesInput>
    OR?: Enumerable<SiteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SiteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    cosUrl?: StringWithAggregatesFilter | string
    siteTemplateId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    slotData?: JsonWithAggregatesFilter
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    projects?: ProjectUsersListRelationFilter
    links?: LinkListRelationFilter
  }

  export type UserOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    projects?: ProjectUsersOrderByRelationAggregateInput
    links?: LinkOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    refresh_token_expires_in?: IntNullableFilter | number | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refresh_token?: StringNullableWithAggregatesFilter | string | null
    refresh_token_expires_in?: IntNullableWithAggregatesFilter | number | null
    access_token?: StringNullableWithAggregatesFilter | string | null
    expires_at?: IntNullableWithAggregatesFilter | number | null
    token_type?: StringNullableWithAggregatesFilter | string | null
    scope?: StringNullableWithAggregatesFilter | string | null
    id_token?: StringNullableWithAggregatesFilter | string | null
    session_state?: StringNullableWithAggregatesFilter | string | null
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = {
    id?: string
    sessionToken?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sessionToken?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: Enumerable<VerificationTokenWhereInput>
    OR?: Enumerable<VerificationTokenWhereInput>
    NOT?: Enumerable<VerificationTokenWhereInput>
    identifier?: StringFilter | string
    token?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type VerificationTokenOrderByWithRelationAndSearchRelevanceInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = {
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
  }

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    identifier?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProjectWhereInput = {
    AND?: Enumerable<ProjectWhereInput>
    OR?: Enumerable<ProjectWhereInput>
    NOT?: Enumerable<ProjectWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    logo?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    type?: StringFilter | string
    usage?: IntFilter | number
    usageLimit?: IntFilter | number
    plan?: StringFilter | string
    stripeId?: StringNullableFilter | string | null
    billingCycleStart?: IntNullableFilter | number | null
    region?: StringNullableFilter | string | null
    endpoint?: StringNullableFilter | string | null
    bucket?: StringNullableFilter | string | null
    useHost?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    users?: ProjectUsersListRelationFilter
    invites?: ProjectInviteListRelationFilter
    sentEmails?: SentEmailListRelationFilter
    domains?: DomainListRelationFilter
    links?: LinkListRelationFilter
    tags?: TagListRelationFilter
  }

  export type ProjectOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    password?: SortOrder
    type?: SortOrder
    usage?: SortOrder
    usageLimit?: SortOrder
    plan?: SortOrder
    stripeId?: SortOrder
    billingCycleStart?: SortOrder
    region?: SortOrder
    endpoint?: SortOrder
    bucket?: SortOrder
    useHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    users?: ProjectUsersOrderByRelationAggregateInput
    invites?: ProjectInviteOrderByRelationAggregateInput
    sentEmails?: SentEmailOrderByRelationAggregateInput
    domains?: DomainOrderByRelationAggregateInput
    links?: LinkOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    _relevance?: ProjectOrderByRelevanceInput
  }

  export type ProjectWhereUniqueInput = {
    id?: string
    slug?: string
    stripeId?: string
  }

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    password?: SortOrder
    type?: SortOrder
    usage?: SortOrder
    usageLimit?: SortOrder
    plan?: SortOrder
    stripeId?: SortOrder
    billingCycleStart?: SortOrder
    region?: SortOrder
    endpoint?: SortOrder
    bucket?: SortOrder
    useHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    logo?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    type?: StringWithAggregatesFilter | string
    usage?: IntWithAggregatesFilter | number
    usageLimit?: IntWithAggregatesFilter | number
    plan?: StringWithAggregatesFilter | string
    stripeId?: StringNullableWithAggregatesFilter | string | null
    billingCycleStart?: IntNullableWithAggregatesFilter | number | null
    region?: StringNullableWithAggregatesFilter | string | null
    endpoint?: StringNullableWithAggregatesFilter | string | null
    bucket?: StringNullableWithAggregatesFilter | string | null
    useHost?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type ProjectInviteWhereInput = {
    AND?: Enumerable<ProjectInviteWhereInput>
    OR?: Enumerable<ProjectInviteWhereInput>
    NOT?: Enumerable<ProjectInviteWhereInput>
    email?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    projectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectInviteOrderByWithRelationAndSearchRelevanceInput = {
    email?: SortOrder
    expires?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ProjectInviteOrderByRelevanceInput
  }

  export type ProjectInviteWhereUniqueInput = {
    email_projectId?: ProjectInviteEmailProjectIdCompoundUniqueInput
  }

  export type ProjectInviteOrderByWithAggregationInput = {
    email?: SortOrder
    expires?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectInviteCountOrderByAggregateInput
    _max?: ProjectInviteMaxOrderByAggregateInput
    _min?: ProjectInviteMinOrderByAggregateInput
  }

  export type ProjectInviteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectInviteScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectInviteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectInviteScalarWhereWithAggregatesInput>
    email?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
    projectId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProjectUsersWhereInput = {
    AND?: Enumerable<ProjectUsersWhereInput>
    OR?: Enumerable<ProjectUsersWhereInput>
    NOT?: Enumerable<ProjectUsersWhereInput>
    id?: StringFilter | string
    role?: EnumRoleFilter | Role
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    projectId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectUsersOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ProjectUsersOrderByRelevanceInput
  }

  export type ProjectUsersWhereUniqueInput = {
    id?: string
    userId_projectId?: ProjectUsersUserIdProjectIdCompoundUniqueInput
  }

  export type ProjectUsersOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    _count?: ProjectUsersCountOrderByAggregateInput
    _max?: ProjectUsersMaxOrderByAggregateInput
    _min?: ProjectUsersMinOrderByAggregateInput
  }

  export type ProjectUsersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectUsersScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectUsersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectUsersScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    role?: EnumRoleWithAggregatesFilter | Role
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
    projectId?: StringWithAggregatesFilter | string
  }

  export type SentEmailWhereInput = {
    AND?: Enumerable<SentEmailWhereInput>
    OR?: Enumerable<SentEmailWhereInput>
    NOT?: Enumerable<SentEmailWhereInput>
    id?: StringFilter | string
    type?: EnumEmailTypeFilter | EmailType
    createdAt?: DateTimeFilter | Date | string
    projectId?: StringNullableFilter | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput> | null
  }

  export type SentEmailOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    _relevance?: SentEmailOrderByRelevanceInput
  }

  export type SentEmailWhereUniqueInput = {
    id?: string
  }

  export type SentEmailOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    _count?: SentEmailCountOrderByAggregateInput
    _max?: SentEmailMaxOrderByAggregateInput
    _min?: SentEmailMinOrderByAggregateInput
  }

  export type SentEmailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SentEmailScalarWhereWithAggregatesInput>
    OR?: Enumerable<SentEmailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SentEmailScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumEmailTypeWithAggregatesFilter | EmailType
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    projectId?: StringNullableWithAggregatesFilter | string | null
  }

  export type DomainWhereInput = {
    AND?: Enumerable<DomainWhereInput>
    OR?: Enumerable<DomainWhereInput>
    NOT?: Enumerable<DomainWhereInput>
    id?: StringFilter | string
    slug?: StringFilter | string
    verified?: BoolFilter | boolean
    target?: StringNullableFilter | string | null
    type?: StringFilter | string
    description?: StringNullableFilter | string | null
    projectId?: StringNullableFilter | string | null
    primary?: BoolFilter | boolean
    lastChecked?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput> | null
    links?: LinkListRelationFilter
  }

  export type DomainOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    slug?: SortOrder
    verified?: SortOrder
    target?: SortOrder
    type?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    primary?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    links?: LinkOrderByRelationAggregateInput
    _relevance?: DomainOrderByRelevanceInput
  }

  export type DomainWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type DomainOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    verified?: SortOrder
    target?: SortOrder
    type?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    primary?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DomainCountOrderByAggregateInput
    _max?: DomainMaxOrderByAggregateInput
    _min?: DomainMinOrderByAggregateInput
  }

  export type DomainScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DomainScalarWhereWithAggregatesInput>
    OR?: Enumerable<DomainScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DomainScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    verified?: BoolWithAggregatesFilter | boolean
    target?: StringNullableWithAggregatesFilter | string | null
    type?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    projectId?: StringNullableWithAggregatesFilter | string | null
    primary?: BoolWithAggregatesFilter | boolean
    lastChecked?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LinkWhereInput = {
    AND?: Enumerable<LinkWhereInput>
    OR?: Enumerable<LinkWhereInput>
    NOT?: Enumerable<LinkWhereInput>
    id?: StringFilter | string
    domain?: StringFilter | string
    key?: StringFilter | string
    url?: StringFilter | string
    archived?: BoolFilter | boolean
    expiresAt?: DateTimeNullableFilter | Date | string | null
    password?: StringNullableFilter | string | null
    proxy?: BoolFilter | boolean
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    utm_source?: StringNullableFilter | string | null
    utm_medium?: StringNullableFilter | string | null
    utm_campaign?: StringNullableFilter | string | null
    utm_term?: StringNullableFilter | string | null
    utm_content?: StringNullableFilter | string | null
    rewrite?: BoolFilter | boolean
    ios?: StringNullableFilter | string | null
    android?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    projectId?: StringNullableFilter | string | null
    clicks?: IntFilter | number
    publicStats?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    tagId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput> | null
    projectDomain?: XOR<DomainRelationFilter, DomainWhereInput> | null
    tag?: XOR<TagRelationFilter, TagWhereInput> | null
  }

  export type LinkOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    domain?: SortOrder
    key?: SortOrder
    url?: SortOrder
    archived?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    proxy?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_term?: SortOrder
    utm_content?: SortOrder
    rewrite?: SortOrder
    ios?: SortOrder
    android?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    clicks?: SortOrder
    publicStats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tagId?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    projectDomain?: DomainOrderByWithRelationAndSearchRelevanceInput
    tag?: TagOrderByWithRelationAndSearchRelevanceInput
    _relevance?: LinkOrderByRelevanceInput
  }

  export type LinkWhereUniqueInput = {
    id?: string
    domain_key?: LinkDomainKeyCompoundUniqueInput
  }

  export type LinkOrderByWithAggregationInput = {
    id?: SortOrder
    domain?: SortOrder
    key?: SortOrder
    url?: SortOrder
    archived?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    proxy?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_term?: SortOrder
    utm_content?: SortOrder
    rewrite?: SortOrder
    ios?: SortOrder
    android?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    clicks?: SortOrder
    publicStats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tagId?: SortOrder
    _count?: LinkCountOrderByAggregateInput
    _avg?: LinkAvgOrderByAggregateInput
    _max?: LinkMaxOrderByAggregateInput
    _min?: LinkMinOrderByAggregateInput
    _sum?: LinkSumOrderByAggregateInput
  }

  export type LinkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LinkScalarWhereWithAggregatesInput>
    OR?: Enumerable<LinkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LinkScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    domain?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    archived?: BoolWithAggregatesFilter | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    proxy?: BoolWithAggregatesFilter | boolean
    title?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    utm_source?: StringNullableWithAggregatesFilter | string | null
    utm_medium?: StringNullableWithAggregatesFilter | string | null
    utm_campaign?: StringNullableWithAggregatesFilter | string | null
    utm_term?: StringNullableWithAggregatesFilter | string | null
    utm_content?: StringNullableWithAggregatesFilter | string | null
    rewrite?: BoolWithAggregatesFilter | boolean
    ios?: StringNullableWithAggregatesFilter | string | null
    android?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    projectId?: StringNullableWithAggregatesFilter | string | null
    clicks?: IntWithAggregatesFilter | number
    publicStats?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    tagId?: StringNullableWithAggregatesFilter | string | null
  }

  export type TagWhereInput = {
    AND?: Enumerable<TagWhereInput>
    OR?: Enumerable<TagWhereInput>
    NOT?: Enumerable<TagWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    color?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    projectId?: StringFilter | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    links?: LinkListRelationFilter
  }

  export type TagOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationAndSearchRelevanceInput
    links?: LinkOrderByRelationAggregateInput
    _relevance?: TagOrderByRelevanceInput
  }

  export type TagWhereUniqueInput = {
    id?: string
    name_projectId?: TagNameProjectIdCompoundUniqueInput
  }

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    color?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    projectId?: StringWithAggregatesFilter | string
  }

  export type jackson_indexWhereInput = {
    AND?: Enumerable<jackson_indexWhereInput>
    OR?: Enumerable<jackson_indexWhereInput>
    NOT?: Enumerable<jackson_indexWhereInput>
    id?: IntFilter | number
    key?: StringFilter | string
    storeKey?: StringFilter | string
  }

  export type jackson_indexOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    key?: SortOrder
    storeKey?: SortOrder
    _relevance?: jackson_indexOrderByRelevanceInput
  }

  export type jackson_indexWhereUniqueInput = {
    id?: number
  }

  export type jackson_indexOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    storeKey?: SortOrder
    _count?: jackson_indexCountOrderByAggregateInput
    _avg?: jackson_indexAvgOrderByAggregateInput
    _max?: jackson_indexMaxOrderByAggregateInput
    _min?: jackson_indexMinOrderByAggregateInput
    _sum?: jackson_indexSumOrderByAggregateInput
  }

  export type jackson_indexScalarWhereWithAggregatesInput = {
    AND?: Enumerable<jackson_indexScalarWhereWithAggregatesInput>
    OR?: Enumerable<jackson_indexScalarWhereWithAggregatesInput>
    NOT?: Enumerable<jackson_indexScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    key?: StringWithAggregatesFilter | string
    storeKey?: StringWithAggregatesFilter | string
  }

  export type jackson_storeWhereInput = {
    AND?: Enumerable<jackson_storeWhereInput>
    OR?: Enumerable<jackson_storeWhereInput>
    NOT?: Enumerable<jackson_storeWhereInput>
    key?: StringFilter | string
    value?: StringFilter | string
    iv?: StringNullableFilter | string | null
    tag?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    modifiedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type jackson_storeOrderByWithRelationAndSearchRelevanceInput = {
    key?: SortOrder
    value?: SortOrder
    iv?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    _relevance?: jackson_storeOrderByRelevanceInput
  }

  export type jackson_storeWhereUniqueInput = {
    key?: string
  }

  export type jackson_storeOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    iv?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    _count?: jackson_storeCountOrderByAggregateInput
    _max?: jackson_storeMaxOrderByAggregateInput
    _min?: jackson_storeMinOrderByAggregateInput
  }

  export type jackson_storeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<jackson_storeScalarWhereWithAggregatesInput>
    OR?: Enumerable<jackson_storeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<jackson_storeScalarWhereWithAggregatesInput>
    key?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    iv?: StringNullableWithAggregatesFilter | string | null
    tag?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    modifiedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type jackson_ttlWhereInput = {
    AND?: Enumerable<jackson_ttlWhereInput>
    OR?: Enumerable<jackson_ttlWhereInput>
    NOT?: Enumerable<jackson_ttlWhereInput>
    key?: StringFilter | string
    expiresAt?: BigIntFilter | bigint | number
  }

  export type jackson_ttlOrderByWithRelationAndSearchRelevanceInput = {
    key?: SortOrder
    expiresAt?: SortOrder
    _relevance?: jackson_ttlOrderByRelevanceInput
  }

  export type jackson_ttlWhereUniqueInput = {
    key?: string
  }

  export type jackson_ttlOrderByWithAggregationInput = {
    key?: SortOrder
    expiresAt?: SortOrder
    _count?: jackson_ttlCountOrderByAggregateInput
    _avg?: jackson_ttlAvgOrderByAggregateInput
    _max?: jackson_ttlMaxOrderByAggregateInput
    _min?: jackson_ttlMinOrderByAggregateInput
    _sum?: jackson_ttlSumOrderByAggregateInput
  }

  export type jackson_ttlScalarWhereWithAggregatesInput = {
    AND?: Enumerable<jackson_ttlScalarWhereWithAggregatesInput>
    OR?: Enumerable<jackson_ttlScalarWhereWithAggregatesInput>
    NOT?: Enumerable<jackson_ttlScalarWhereWithAggregatesInput>
    key?: StringWithAggregatesFilter | string
    expiresAt?: BigIntWithAggregatesFilter | bigint | number
  }

  export type AuditsCreateInput = {
    createdAt?: Date | string
    auditId: number
    auditType: string
    userId: string
    username?: string | null
    action: string
    auditChanges: string
    version: number
  }

  export type AuditsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    auditId: number
    auditType: string
    userId: string
    username?: string | null
    action: string
    auditChanges: string
    version: number
  }

  export type AuditsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditId?: IntFieldUpdateOperationsInput | number
    auditType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    auditChanges?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type AuditsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditId?: IntFieldUpdateOperationsInput | number
    auditType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    auditChanges?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type AuditsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    auditId: number
    auditType: string
    userId: string
    username?: string | null
    action: string
    auditChanges: string
    version: number
  }

  export type AuditsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditId?: IntFieldUpdateOperationsInput | number
    auditType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    auditChanges?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type AuditsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditId?: IntFieldUpdateOperationsInput | number
    auditType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    auditChanges?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SiteTemplateCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    template: string
    site?: SiteCreateNestedManyWithoutSiteTemplateInput
    siteTemplateDataDef?: SiteTemplateDataDefCreateNestedOneWithoutSiteTemplateInput
  }

  export type SiteTemplateUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    template: string
    site?: SiteUncheckedCreateNestedManyWithoutSiteTemplateInput
    siteTemplateDataDef?: SiteTemplateDataDefUncheckedCreateNestedOneWithoutSiteTemplateInput
  }

  export type SiteTemplateUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    site?: SiteUpdateManyWithoutSiteTemplateNestedInput
    siteTemplateDataDef?: SiteTemplateDataDefUpdateOneWithoutSiteTemplateNestedInput
  }

  export type SiteTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    site?: SiteUncheckedUpdateManyWithoutSiteTemplateNestedInput
    siteTemplateDataDef?: SiteTemplateDataDefUncheckedUpdateOneWithoutSiteTemplateNestedInput
  }

  export type SiteTemplateCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    template: string
  }

  export type SiteTemplateUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
  }

  export type SiteTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
  }

  export type SiteTemplateDataDefCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    defData: JsonNullValueInput | InputJsonValue
    siteTemplate: SiteTemplateCreateNestedOneWithoutSiteTemplateDataDefInput
  }

  export type SiteTemplateDataDefUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    siteTemplateId: number
    defData: JsonNullValueInput | InputJsonValue
  }

  export type SiteTemplateDataDefUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    defData?: JsonNullValueInput | InputJsonValue
    siteTemplate?: SiteTemplateUpdateOneRequiredWithoutSiteTemplateDataDefNestedInput
  }

  export type SiteTemplateDataDefUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    siteTemplateId?: IntFieldUpdateOperationsInput | number
    defData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteTemplateDataDefCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    siteTemplateId: number
    defData: JsonNullValueInput | InputJsonValue
  }

  export type SiteTemplateDataDefUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    defData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteTemplateDataDefUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    siteTemplateId?: IntFieldUpdateOperationsInput | number
    defData?: JsonNullValueInput | InputJsonValue
  }

  export type CustomerCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    extendData?: NullableJsonNullValueInput | InputJsonValue
    site?: SiteCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    extendData?: NullableJsonNullValueInput | InputJsonValue
    site?: SiteUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    extendData?: NullableJsonNullValueInput | InputJsonValue
    site?: SiteUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    extendData?: NullableJsonNullValueInput | InputJsonValue
    site?: SiteUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SiteCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    slotData?: JsonNullValueInput | InputJsonValue
    siteTemplate: SiteTemplateCreateNestedOneWithoutSiteInput
    customer: CustomerCreateNestedOneWithoutSiteInput
  }

  export type SiteUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    siteTemplateId: number
    customerId: number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    slotData?: JsonNullValueInput | InputJsonValue
    siteTemplate?: SiteTemplateUpdateOneRequiredWithoutSiteNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    siteTemplateId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    siteTemplateId: number
    customerId: number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    siteTemplateId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    projects?: ProjectUsersCreateNestedManyWithoutUserInput
    links?: LinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUsersUncheckedCreateNestedManyWithoutUserInput
    links?: LinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    projects?: ProjectUsersUpdateManyWithoutUserNestedInput
    links?: LinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUsersUncheckedUpdateManyWithoutUserNestedInput
    links?: LinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailCreateNestedManyWithoutProjectInput
    domains?: DomainCreateNestedManyWithoutProjectInput
    links?: LinkCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutProjectInput
    domains?: DomainUncheckedCreateNestedManyWithoutProjectInput
    links?: LinkUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUpdateManyWithoutProjectNestedInput
    domains?: DomainUpdateManyWithoutProjectNestedInput
    links?: LinkUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutProjectNestedInput
    domains?: DomainUncheckedUpdateManyWithoutProjectNestedInput
    links?: LinkUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectInviteCreateInput = {
    email: string
    expires: Date | string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutInvitesInput
  }

  export type ProjectInviteUncheckedCreateInput = {
    email: string
    expires: Date | string
    projectId: string
    createdAt?: Date | string
  }

  export type ProjectInviteUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type ProjectInviteUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteCreateManyInput = {
    email: string
    expires: Date | string
    projectId: string
    createdAt?: Date | string
  }

  export type ProjectInviteUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUsersCreateInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    project: ProjectCreateNestedOneWithoutUsersInput
  }

  export type ProjectUsersUncheckedCreateInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
  }

  export type ProjectUsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    project?: ProjectUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ProjectUsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUsersCreateManyInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    projectId: string
  }

  export type ProjectUsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type SentEmailCreateInput = {
    id?: string
    type: EmailType
    createdAt?: Date | string
    project?: ProjectCreateNestedOneWithoutSentEmailsInput
  }

  export type SentEmailUncheckedCreateInput = {
    id?: string
    type: EmailType
    createdAt?: Date | string
    projectId?: string | null
  }

  export type SentEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | EmailType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutSentEmailsNestedInput
  }

  export type SentEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | EmailType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SentEmailCreateManyInput = {
    id?: string
    type: EmailType
    createdAt?: Date | string
    projectId?: string | null
  }

  export type SentEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | EmailType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | EmailType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomainCreateInput = {
    id?: string
    slug: string
    verified?: boolean
    target?: string | null
    type?: string
    description?: string | null
    primary?: boolean
    lastChecked?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutDomainsInput
    links?: LinkCreateNestedManyWithoutProjectDomainInput
  }

  export type DomainUncheckedCreateInput = {
    id?: string
    slug: string
    verified?: boolean
    target?: string | null
    type?: string
    description?: string | null
    projectId?: string | null
    primary?: boolean
    lastChecked?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: LinkUncheckedCreateNestedManyWithoutProjectDomainInput
  }

  export type DomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutDomainsNestedInput
    links?: LinkUpdateManyWithoutProjectDomainNestedInput
  }

  export type DomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: LinkUncheckedUpdateManyWithoutProjectDomainNestedInput
  }

  export type DomainCreateManyInput = {
    id?: string
    slug: string
    verified?: boolean
    target?: string | null
    type?: string
    description?: string | null
    projectId?: string | null
    primary?: boolean
    lastChecked?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkCreateInput = {
    id?: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutLinksInput
    project?: ProjectCreateNestedOneWithoutLinksInput
    projectDomain?: DomainCreateNestedOneWithoutLinksInput
    tag?: TagCreateNestedOneWithoutLinksInput
  }

  export type LinkUncheckedCreateInput = {
    id?: string
    domain: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    userId?: string | null
    projectId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tagId?: string | null
  }

  export type LinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLinksNestedInput
    project?: ProjectUpdateOneWithoutLinksNestedInput
    projectDomain?: DomainUpdateOneWithoutLinksNestedInput
    tag?: TagUpdateOneWithoutLinksNestedInput
  }

  export type LinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LinkCreateManyInput = {
    id?: string
    domain: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    userId?: string | null
    projectId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tagId?: string | null
  }

  export type LinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTagsInput
    links?: LinkCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    links?: LinkUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTagsNestedInput
    links?: LinkUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    links?: LinkUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type jackson_indexCreateInput = {
    key: string
    storeKey: string
  }

  export type jackson_indexUncheckedCreateInput = {
    id?: number
    key: string
    storeKey: string
  }

  export type jackson_indexUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    storeKey?: StringFieldUpdateOperationsInput | string
  }

  export type jackson_indexUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    storeKey?: StringFieldUpdateOperationsInput | string
  }

  export type jackson_indexCreateManyInput = {
    id?: number
    key: string
    storeKey: string
  }

  export type jackson_indexUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    storeKey?: StringFieldUpdateOperationsInput | string
  }

  export type jackson_indexUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    storeKey?: StringFieldUpdateOperationsInput | string
  }

  export type jackson_storeCreateInput = {
    key: string
    value: string
    iv?: string | null
    tag?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
  }

  export type jackson_storeUncheckedCreateInput = {
    key: string
    value: string
    iv?: string | null
    tag?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
  }

  export type jackson_storeUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jackson_storeUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jackson_storeCreateManyInput = {
    key: string
    value: string
    iv?: string | null
    tag?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
  }

  export type jackson_storeUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jackson_storeUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jackson_ttlCreateInput = {
    key: string
    expiresAt: bigint | number
  }

  export type jackson_ttlUncheckedCreateInput = {
    key: string
    expiresAt: bigint | number
  }

  export type jackson_ttlUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type jackson_ttlUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type jackson_ttlCreateManyInput = {
    key: string
    expiresAt: bigint | number
  }

  export type jackson_ttlUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type jackson_ttlUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    expiresAt?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type AuditsOrderByRelevanceInput = {
    fields: Enumerable<AuditsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AuditsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    auditId?: SortOrder
    auditType?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    action?: SortOrder
    auditChanges?: SortOrder
    version?: SortOrder
  }

  export type AuditsAvgOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    version?: SortOrder
  }

  export type AuditsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    auditId?: SortOrder
    auditType?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    action?: SortOrder
    auditChanges?: SortOrder
    version?: SortOrder
  }

  export type AuditsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    auditId?: SortOrder
    auditType?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    action?: SortOrder
    auditChanges?: SortOrder
    version?: SortOrder
  }

  export type AuditsSumOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    version?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type SiteListRelationFilter = {
    every?: SiteWhereInput
    some?: SiteWhereInput
    none?: SiteWhereInput
  }

  export type SiteTemplateDataDefRelationFilter = {
    is?: SiteTemplateDataDefWhereInput | null
    isNot?: SiteTemplateDataDefWhereInput | null
  }

  export type SiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteTemplateOrderByRelevanceInput = {
    fields: Enumerable<SiteTemplateOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type SiteTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    template?: SortOrder
  }

  export type SiteTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SiteTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    template?: SortOrder
  }

  export type SiteTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    template?: SortOrder
  }

  export type SiteTemplateSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type SiteTemplateRelationFilter = {
    is?: SiteTemplateWhereInput
    isNot?: SiteTemplateWhereInput
  }

  export type SiteTemplateDataDefCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    siteTemplateId?: SortOrder
    defData?: SortOrder
  }

  export type SiteTemplateDataDefAvgOrderByAggregateInput = {
    id?: SortOrder
    siteTemplateId?: SortOrder
  }

  export type SiteTemplateDataDefMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    siteTemplateId?: SortOrder
  }

  export type SiteTemplateDataDefMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    siteTemplateId?: SortOrder
  }

  export type SiteTemplateDataDefSumOrderByAggregateInput = {
    id?: SortOrder
    siteTemplateId?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type CustomerOrderByRelevanceInput = {
    fields: Enumerable<CustomerOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    extendData?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type SiteOrderByRelevanceInput = {
    fields: Enumerable<SiteOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type SiteCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    cosUrl?: SortOrder
    siteTemplateId?: SortOrder
    customerId?: SortOrder
    slotData?: SortOrder
  }

  export type SiteAvgOrderByAggregateInput = {
    id?: SortOrder
    siteTemplateId?: SortOrder
    customerId?: SortOrder
  }

  export type SiteMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    cosUrl?: SortOrder
    siteTemplateId?: SortOrder
    customerId?: SortOrder
  }

  export type SiteMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    cosUrl?: SortOrder
    siteTemplateId?: SortOrder
    customerId?: SortOrder
  }

  export type SiteSumOrderByAggregateInput = {
    id?: SortOrder
    siteTemplateId?: SortOrder
    customerId?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ProjectUsersListRelationFilter = {
    every?: ProjectUsersWhereInput
    some?: ProjectUsersWhereInput
    none?: ProjectUsersWhereInput
  }

  export type LinkListRelationFilter = {
    every?: LinkWhereInput
    some?: LinkWhereInput
    none?: LinkWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectUsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: Enumerable<UserOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountOrderByRelevanceInput = {
    fields: Enumerable<AccountOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    refresh_token_expires_in?: SortOrder
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    refresh_token_expires_in?: SortOrder
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type SessionOrderByRelevanceInput = {
    fields: Enumerable<SessionOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: Enumerable<VerificationTokenOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type ProjectInviteListRelationFilter = {
    every?: ProjectInviteWhereInput
    some?: ProjectInviteWhereInput
    none?: ProjectInviteWhereInput
  }

  export type SentEmailListRelationFilter = {
    every?: SentEmailWhereInput
    some?: SentEmailWhereInput
    none?: SentEmailWhereInput
  }

  export type DomainListRelationFilter = {
    every?: DomainWhereInput
    some?: DomainWhereInput
    none?: DomainWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type ProjectInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SentEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelevanceInput = {
    fields: Enumerable<ProjectOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    password?: SortOrder
    type?: SortOrder
    usage?: SortOrder
    usageLimit?: SortOrder
    plan?: SortOrder
    stripeId?: SortOrder
    billingCycleStart?: SortOrder
    region?: SortOrder
    endpoint?: SortOrder
    bucket?: SortOrder
    useHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    usage?: SortOrder
    usageLimit?: SortOrder
    billingCycleStart?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    password?: SortOrder
    type?: SortOrder
    usage?: SortOrder
    usageLimit?: SortOrder
    plan?: SortOrder
    stripeId?: SortOrder
    billingCycleStart?: SortOrder
    region?: SortOrder
    endpoint?: SortOrder
    bucket?: SortOrder
    useHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    password?: SortOrder
    type?: SortOrder
    usage?: SortOrder
    usageLimit?: SortOrder
    plan?: SortOrder
    stripeId?: SortOrder
    billingCycleStart?: SortOrder
    region?: SortOrder
    endpoint?: SortOrder
    bucket?: SortOrder
    useHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    usage?: SortOrder
    usageLimit?: SortOrder
    billingCycleStart?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectInviteOrderByRelevanceInput = {
    fields: Enumerable<ProjectInviteOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProjectInviteEmailProjectIdCompoundUniqueInput = {
    email: string
    projectId: string
  }

  export type ProjectInviteCountOrderByAggregateInput = {
    email?: SortOrder
    expires?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectInviteMaxOrderByAggregateInput = {
    email?: SortOrder
    expires?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectInviteMinOrderByAggregateInput = {
    email?: SortOrder
    expires?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type ProjectUsersOrderByRelevanceInput = {
    fields: Enumerable<ProjectUsersOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProjectUsersUserIdProjectIdCompoundUniqueInput = {
    userId: string
    projectId: string
  }

  export type ProjectUsersCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectUsersMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectUsersMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type EnumEmailTypeFilter = {
    equals?: EmailType
    in?: Enumerable<EmailType>
    notIn?: Enumerable<EmailType>
    not?: NestedEnumEmailTypeFilter | EmailType
  }

  export type SentEmailOrderByRelevanceInput = {
    fields: Enumerable<SentEmailOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type SentEmailCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type SentEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type SentEmailMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnumEmailTypeWithAggregatesFilter = {
    equals?: EmailType
    in?: Enumerable<EmailType>
    notIn?: Enumerable<EmailType>
    not?: NestedEnumEmailTypeWithAggregatesFilter | EmailType
    _count?: NestedIntFilter
    _min?: NestedEnumEmailTypeFilter
    _max?: NestedEnumEmailTypeFilter
  }

  export type DomainOrderByRelevanceInput = {
    fields: Enumerable<DomainOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type DomainCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    verified?: SortOrder
    target?: SortOrder
    type?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    primary?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    verified?: SortOrder
    target?: SortOrder
    type?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    primary?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    verified?: SortOrder
    target?: SortOrder
    type?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    primary?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainRelationFilter = {
    is?: DomainWhereInput | null
    isNot?: DomainWhereInput | null
  }

  export type TagRelationFilter = {
    is?: TagWhereInput | null
    isNot?: TagWhereInput | null
  }

  export type LinkOrderByRelevanceInput = {
    fields: Enumerable<LinkOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LinkDomainKeyCompoundUniqueInput = {
    domain: string
    key: string
  }

  export type LinkCountOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    key?: SortOrder
    url?: SortOrder
    archived?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    proxy?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_term?: SortOrder
    utm_content?: SortOrder
    rewrite?: SortOrder
    ios?: SortOrder
    android?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    clicks?: SortOrder
    publicStats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tagId?: SortOrder
  }

  export type LinkAvgOrderByAggregateInput = {
    clicks?: SortOrder
  }

  export type LinkMaxOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    key?: SortOrder
    url?: SortOrder
    archived?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    proxy?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_term?: SortOrder
    utm_content?: SortOrder
    rewrite?: SortOrder
    ios?: SortOrder
    android?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    clicks?: SortOrder
    publicStats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tagId?: SortOrder
  }

  export type LinkMinOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    key?: SortOrder
    url?: SortOrder
    archived?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    proxy?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_term?: SortOrder
    utm_content?: SortOrder
    rewrite?: SortOrder
    ios?: SortOrder
    android?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    clicks?: SortOrder
    publicStats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tagId?: SortOrder
  }

  export type LinkSumOrderByAggregateInput = {
    clicks?: SortOrder
  }

  export type TagOrderByRelevanceInput = {
    fields: Enumerable<TagOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type TagNameProjectIdCompoundUniqueInput = {
    name: string
    projectId: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type jackson_indexOrderByRelevanceInput = {
    fields: Enumerable<jackson_indexOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type jackson_indexCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    storeKey?: SortOrder
  }

  export type jackson_indexAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type jackson_indexMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    storeKey?: SortOrder
  }

  export type jackson_indexMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    storeKey?: SortOrder
  }

  export type jackson_indexSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type jackson_storeOrderByRelevanceInput = {
    fields: Enumerable<jackson_storeOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type jackson_storeCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    iv?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
  }

  export type jackson_storeMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    iv?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
  }

  export type jackson_storeMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    iv?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type jackson_ttlOrderByRelevanceInput = {
    fields: Enumerable<jackson_ttlOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type jackson_ttlCountOrderByAggregateInput = {
    key?: SortOrder
    expiresAt?: SortOrder
  }

  export type jackson_ttlAvgOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type jackson_ttlMaxOrderByAggregateInput = {
    key?: SortOrder
    expiresAt?: SortOrder
  }

  export type jackson_ttlMinOrderByAggregateInput = {
    key?: SortOrder
    expiresAt?: SortOrder
  }

  export type jackson_ttlSumOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type SiteCreateNestedManyWithoutSiteTemplateInput = {
    create?: XOR<Enumerable<SiteCreateWithoutSiteTemplateInput>, Enumerable<SiteUncheckedCreateWithoutSiteTemplateInput>>
    connectOrCreate?: Enumerable<SiteCreateOrConnectWithoutSiteTemplateInput>
    createMany?: SiteCreateManySiteTemplateInputEnvelope
    connect?: Enumerable<SiteWhereUniqueInput>
  }

  export type SiteTemplateDataDefCreateNestedOneWithoutSiteTemplateInput = {
    create?: XOR<SiteTemplateDataDefCreateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedCreateWithoutSiteTemplateInput>
    connectOrCreate?: SiteTemplateDataDefCreateOrConnectWithoutSiteTemplateInput
    connect?: SiteTemplateDataDefWhereUniqueInput
  }

  export type SiteUncheckedCreateNestedManyWithoutSiteTemplateInput = {
    create?: XOR<Enumerable<SiteCreateWithoutSiteTemplateInput>, Enumerable<SiteUncheckedCreateWithoutSiteTemplateInput>>
    connectOrCreate?: Enumerable<SiteCreateOrConnectWithoutSiteTemplateInput>
    createMany?: SiteCreateManySiteTemplateInputEnvelope
    connect?: Enumerable<SiteWhereUniqueInput>
  }

  export type SiteTemplateDataDefUncheckedCreateNestedOneWithoutSiteTemplateInput = {
    create?: XOR<SiteTemplateDataDefCreateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedCreateWithoutSiteTemplateInput>
    connectOrCreate?: SiteTemplateDataDefCreateOrConnectWithoutSiteTemplateInput
    connect?: SiteTemplateDataDefWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SiteUpdateManyWithoutSiteTemplateNestedInput = {
    create?: XOR<Enumerable<SiteCreateWithoutSiteTemplateInput>, Enumerable<SiteUncheckedCreateWithoutSiteTemplateInput>>
    connectOrCreate?: Enumerable<SiteCreateOrConnectWithoutSiteTemplateInput>
    upsert?: Enumerable<SiteUpsertWithWhereUniqueWithoutSiteTemplateInput>
    createMany?: SiteCreateManySiteTemplateInputEnvelope
    set?: Enumerable<SiteWhereUniqueInput>
    disconnect?: Enumerable<SiteWhereUniqueInput>
    delete?: Enumerable<SiteWhereUniqueInput>
    connect?: Enumerable<SiteWhereUniqueInput>
    update?: Enumerable<SiteUpdateWithWhereUniqueWithoutSiteTemplateInput>
    updateMany?: Enumerable<SiteUpdateManyWithWhereWithoutSiteTemplateInput>
    deleteMany?: Enumerable<SiteScalarWhereInput>
  }

  export type SiteTemplateDataDefUpdateOneWithoutSiteTemplateNestedInput = {
    create?: XOR<SiteTemplateDataDefCreateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedCreateWithoutSiteTemplateInput>
    connectOrCreate?: SiteTemplateDataDefCreateOrConnectWithoutSiteTemplateInput
    upsert?: SiteTemplateDataDefUpsertWithoutSiteTemplateInput
    disconnect?: boolean
    delete?: boolean
    connect?: SiteTemplateDataDefWhereUniqueInput
    update?: XOR<SiteTemplateDataDefUpdateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedUpdateWithoutSiteTemplateInput>
  }

  export type SiteUncheckedUpdateManyWithoutSiteTemplateNestedInput = {
    create?: XOR<Enumerable<SiteCreateWithoutSiteTemplateInput>, Enumerable<SiteUncheckedCreateWithoutSiteTemplateInput>>
    connectOrCreate?: Enumerable<SiteCreateOrConnectWithoutSiteTemplateInput>
    upsert?: Enumerable<SiteUpsertWithWhereUniqueWithoutSiteTemplateInput>
    createMany?: SiteCreateManySiteTemplateInputEnvelope
    set?: Enumerable<SiteWhereUniqueInput>
    disconnect?: Enumerable<SiteWhereUniqueInput>
    delete?: Enumerable<SiteWhereUniqueInput>
    connect?: Enumerable<SiteWhereUniqueInput>
    update?: Enumerable<SiteUpdateWithWhereUniqueWithoutSiteTemplateInput>
    updateMany?: Enumerable<SiteUpdateManyWithWhereWithoutSiteTemplateInput>
    deleteMany?: Enumerable<SiteScalarWhereInput>
  }

  export type SiteTemplateDataDefUncheckedUpdateOneWithoutSiteTemplateNestedInput = {
    create?: XOR<SiteTemplateDataDefCreateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedCreateWithoutSiteTemplateInput>
    connectOrCreate?: SiteTemplateDataDefCreateOrConnectWithoutSiteTemplateInput
    upsert?: SiteTemplateDataDefUpsertWithoutSiteTemplateInput
    disconnect?: boolean
    delete?: boolean
    connect?: SiteTemplateDataDefWhereUniqueInput
    update?: XOR<SiteTemplateDataDefUpdateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedUpdateWithoutSiteTemplateInput>
  }

  export type SiteTemplateCreateNestedOneWithoutSiteTemplateDataDefInput = {
    create?: XOR<SiteTemplateCreateWithoutSiteTemplateDataDefInput, SiteTemplateUncheckedCreateWithoutSiteTemplateDataDefInput>
    connectOrCreate?: SiteTemplateCreateOrConnectWithoutSiteTemplateDataDefInput
    connect?: SiteTemplateWhereUniqueInput
  }

  export type SiteTemplateUpdateOneRequiredWithoutSiteTemplateDataDefNestedInput = {
    create?: XOR<SiteTemplateCreateWithoutSiteTemplateDataDefInput, SiteTemplateUncheckedCreateWithoutSiteTemplateDataDefInput>
    connectOrCreate?: SiteTemplateCreateOrConnectWithoutSiteTemplateDataDefInput
    upsert?: SiteTemplateUpsertWithoutSiteTemplateDataDefInput
    connect?: SiteTemplateWhereUniqueInput
    update?: XOR<SiteTemplateUpdateWithoutSiteTemplateDataDefInput, SiteTemplateUncheckedUpdateWithoutSiteTemplateDataDefInput>
  }

  export type SiteCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<SiteCreateWithoutCustomerInput>, Enumerable<SiteUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<SiteCreateOrConnectWithoutCustomerInput>
    createMany?: SiteCreateManyCustomerInputEnvelope
    connect?: Enumerable<SiteWhereUniqueInput>
  }

  export type SiteUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<SiteCreateWithoutCustomerInput>, Enumerable<SiteUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<SiteCreateOrConnectWithoutCustomerInput>
    createMany?: SiteCreateManyCustomerInputEnvelope
    connect?: Enumerable<SiteWhereUniqueInput>
  }

  export type SiteUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<SiteCreateWithoutCustomerInput>, Enumerable<SiteUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<SiteCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<SiteUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: SiteCreateManyCustomerInputEnvelope
    set?: Enumerable<SiteWhereUniqueInput>
    disconnect?: Enumerable<SiteWhereUniqueInput>
    delete?: Enumerable<SiteWhereUniqueInput>
    connect?: Enumerable<SiteWhereUniqueInput>
    update?: Enumerable<SiteUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<SiteUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<SiteScalarWhereInput>
  }

  export type SiteUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<SiteCreateWithoutCustomerInput>, Enumerable<SiteUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<SiteCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<SiteUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: SiteCreateManyCustomerInputEnvelope
    set?: Enumerable<SiteWhereUniqueInput>
    disconnect?: Enumerable<SiteWhereUniqueInput>
    delete?: Enumerable<SiteWhereUniqueInput>
    connect?: Enumerable<SiteWhereUniqueInput>
    update?: Enumerable<SiteUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<SiteUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<SiteScalarWhereInput>
  }

  export type SiteTemplateCreateNestedOneWithoutSiteInput = {
    create?: XOR<SiteTemplateCreateWithoutSiteInput, SiteTemplateUncheckedCreateWithoutSiteInput>
    connectOrCreate?: SiteTemplateCreateOrConnectWithoutSiteInput
    connect?: SiteTemplateWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSiteInput = {
    create?: XOR<CustomerCreateWithoutSiteInput, CustomerUncheckedCreateWithoutSiteInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSiteInput
    connect?: CustomerWhereUniqueInput
  }

  export type SiteTemplateUpdateOneRequiredWithoutSiteNestedInput = {
    create?: XOR<SiteTemplateCreateWithoutSiteInput, SiteTemplateUncheckedCreateWithoutSiteInput>
    connectOrCreate?: SiteTemplateCreateOrConnectWithoutSiteInput
    upsert?: SiteTemplateUpsertWithoutSiteInput
    connect?: SiteTemplateWhereUniqueInput
    update?: XOR<SiteTemplateUpdateWithoutSiteInput, SiteTemplateUncheckedUpdateWithoutSiteInput>
  }

  export type CustomerUpdateOneRequiredWithoutSiteNestedInput = {
    create?: XOR<CustomerCreateWithoutSiteInput, CustomerUncheckedCreateWithoutSiteInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSiteInput
    upsert?: CustomerUpsertWithoutSiteInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutSiteInput, CustomerUncheckedUpdateWithoutSiteInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type ProjectUsersCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProjectUsersCreateWithoutUserInput>, Enumerable<ProjectUsersUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProjectUsersCreateOrConnectWithoutUserInput>
    createMany?: ProjectUsersCreateManyUserInputEnvelope
    connect?: Enumerable<ProjectUsersWhereUniqueInput>
  }

  export type LinkCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LinkCreateWithoutUserInput>, Enumerable<LinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutUserInput>
    createMany?: LinkCreateManyUserInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type ProjectUsersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProjectUsersCreateWithoutUserInput>, Enumerable<ProjectUsersUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProjectUsersCreateOrConnectWithoutUserInput>
    createMany?: ProjectUsersCreateManyUserInputEnvelope
    connect?: Enumerable<ProjectUsersWhereUniqueInput>
  }

  export type LinkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LinkCreateWithoutUserInput>, Enumerable<LinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutUserInput>
    createMany?: LinkCreateManyUserInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type ProjectUsersUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProjectUsersCreateWithoutUserInput>, Enumerable<ProjectUsersUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProjectUsersCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProjectUsersUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProjectUsersCreateManyUserInputEnvelope
    set?: Enumerable<ProjectUsersWhereUniqueInput>
    disconnect?: Enumerable<ProjectUsersWhereUniqueInput>
    delete?: Enumerable<ProjectUsersWhereUniqueInput>
    connect?: Enumerable<ProjectUsersWhereUniqueInput>
    update?: Enumerable<ProjectUsersUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProjectUsersUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProjectUsersScalarWhereInput>
  }

  export type LinkUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutUserInput>, Enumerable<LinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LinkCreateManyUserInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type ProjectUsersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProjectUsersCreateWithoutUserInput>, Enumerable<ProjectUsersUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProjectUsersCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProjectUsersUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProjectUsersCreateManyUserInputEnvelope
    set?: Enumerable<ProjectUsersWhereUniqueInput>
    disconnect?: Enumerable<ProjectUsersWhereUniqueInput>
    delete?: Enumerable<ProjectUsersWhereUniqueInput>
    connect?: Enumerable<ProjectUsersWhereUniqueInput>
    update?: Enumerable<ProjectUsersUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProjectUsersUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProjectUsersScalarWhereInput>
  }

  export type LinkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutUserInput>, Enumerable<LinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LinkCreateManyUserInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type ProjectUsersCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectUsersCreateWithoutProjectInput>, Enumerable<ProjectUsersUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectUsersCreateOrConnectWithoutProjectInput>
    createMany?: ProjectUsersCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectUsersWhereUniqueInput>
  }

  export type ProjectInviteCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectInviteCreateWithoutProjectInput>, Enumerable<ProjectInviteUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectInviteCreateOrConnectWithoutProjectInput>
    createMany?: ProjectInviteCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectInviteWhereUniqueInput>
  }

  export type SentEmailCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<SentEmailCreateWithoutProjectInput>, Enumerable<SentEmailUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<SentEmailCreateOrConnectWithoutProjectInput>
    createMany?: SentEmailCreateManyProjectInputEnvelope
    connect?: Enumerable<SentEmailWhereUniqueInput>
  }

  export type DomainCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<DomainCreateWithoutProjectInput>, Enumerable<DomainUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<DomainCreateOrConnectWithoutProjectInput>
    createMany?: DomainCreateManyProjectInputEnvelope
    connect?: Enumerable<DomainWhereUniqueInput>
  }

  export type LinkCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<LinkCreateWithoutProjectInput>, Enumerable<LinkUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutProjectInput>
    createMany?: LinkCreateManyProjectInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type TagCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<TagCreateWithoutProjectInput>, Enumerable<TagUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutProjectInput>
    createMany?: TagCreateManyProjectInputEnvelope
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type ProjectUsersUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectUsersCreateWithoutProjectInput>, Enumerable<ProjectUsersUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectUsersCreateOrConnectWithoutProjectInput>
    createMany?: ProjectUsersCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectUsersWhereUniqueInput>
  }

  export type ProjectInviteUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<ProjectInviteCreateWithoutProjectInput>, Enumerable<ProjectInviteUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectInviteCreateOrConnectWithoutProjectInput>
    createMany?: ProjectInviteCreateManyProjectInputEnvelope
    connect?: Enumerable<ProjectInviteWhereUniqueInput>
  }

  export type SentEmailUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<SentEmailCreateWithoutProjectInput>, Enumerable<SentEmailUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<SentEmailCreateOrConnectWithoutProjectInput>
    createMany?: SentEmailCreateManyProjectInputEnvelope
    connect?: Enumerable<SentEmailWhereUniqueInput>
  }

  export type DomainUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<DomainCreateWithoutProjectInput>, Enumerable<DomainUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<DomainCreateOrConnectWithoutProjectInput>
    createMany?: DomainCreateManyProjectInputEnvelope
    connect?: Enumerable<DomainWhereUniqueInput>
  }

  export type LinkUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<LinkCreateWithoutProjectInput>, Enumerable<LinkUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutProjectInput>
    createMany?: LinkCreateManyProjectInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type TagUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<Enumerable<TagCreateWithoutProjectInput>, Enumerable<TagUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutProjectInput>
    createMany?: TagCreateManyProjectInputEnvelope
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type ProjectUsersUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectUsersCreateWithoutProjectInput>, Enumerable<ProjectUsersUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectUsersCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectUsersUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectUsersCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectUsersWhereUniqueInput>
    disconnect?: Enumerable<ProjectUsersWhereUniqueInput>
    delete?: Enumerable<ProjectUsersWhereUniqueInput>
    connect?: Enumerable<ProjectUsersWhereUniqueInput>
    update?: Enumerable<ProjectUsersUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectUsersUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectUsersScalarWhereInput>
  }

  export type ProjectInviteUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectInviteCreateWithoutProjectInput>, Enumerable<ProjectInviteUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectInviteCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectInviteUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectInviteCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectInviteWhereUniqueInput>
    disconnect?: Enumerable<ProjectInviteWhereUniqueInput>
    delete?: Enumerable<ProjectInviteWhereUniqueInput>
    connect?: Enumerable<ProjectInviteWhereUniqueInput>
    update?: Enumerable<ProjectInviteUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectInviteUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectInviteScalarWhereInput>
  }

  export type SentEmailUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<SentEmailCreateWithoutProjectInput>, Enumerable<SentEmailUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<SentEmailCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<SentEmailUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: SentEmailCreateManyProjectInputEnvelope
    set?: Enumerable<SentEmailWhereUniqueInput>
    disconnect?: Enumerable<SentEmailWhereUniqueInput>
    delete?: Enumerable<SentEmailWhereUniqueInput>
    connect?: Enumerable<SentEmailWhereUniqueInput>
    update?: Enumerable<SentEmailUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<SentEmailUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<SentEmailScalarWhereInput>
  }

  export type DomainUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<DomainCreateWithoutProjectInput>, Enumerable<DomainUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<DomainCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<DomainUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: DomainCreateManyProjectInputEnvelope
    set?: Enumerable<DomainWhereUniqueInput>
    disconnect?: Enumerable<DomainWhereUniqueInput>
    delete?: Enumerable<DomainWhereUniqueInput>
    connect?: Enumerable<DomainWhereUniqueInput>
    update?: Enumerable<DomainUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<DomainUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<DomainScalarWhereInput>
  }

  export type LinkUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutProjectInput>, Enumerable<LinkUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: LinkCreateManyProjectInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type TagUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<TagCreateWithoutProjectInput>, Enumerable<TagUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: TagCreateManyProjectInputEnvelope
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type ProjectUsersUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectUsersCreateWithoutProjectInput>, Enumerable<ProjectUsersUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectUsersCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectUsersUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectUsersCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectUsersWhereUniqueInput>
    disconnect?: Enumerable<ProjectUsersWhereUniqueInput>
    delete?: Enumerable<ProjectUsersWhereUniqueInput>
    connect?: Enumerable<ProjectUsersWhereUniqueInput>
    update?: Enumerable<ProjectUsersUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectUsersUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectUsersScalarWhereInput>
  }

  export type ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<ProjectInviteCreateWithoutProjectInput>, Enumerable<ProjectInviteUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<ProjectInviteCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<ProjectInviteUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: ProjectInviteCreateManyProjectInputEnvelope
    set?: Enumerable<ProjectInviteWhereUniqueInput>
    disconnect?: Enumerable<ProjectInviteWhereUniqueInput>
    delete?: Enumerable<ProjectInviteWhereUniqueInput>
    connect?: Enumerable<ProjectInviteWhereUniqueInput>
    update?: Enumerable<ProjectInviteUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<ProjectInviteUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<ProjectInviteScalarWhereInput>
  }

  export type SentEmailUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<SentEmailCreateWithoutProjectInput>, Enumerable<SentEmailUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<SentEmailCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<SentEmailUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: SentEmailCreateManyProjectInputEnvelope
    set?: Enumerable<SentEmailWhereUniqueInput>
    disconnect?: Enumerable<SentEmailWhereUniqueInput>
    delete?: Enumerable<SentEmailWhereUniqueInput>
    connect?: Enumerable<SentEmailWhereUniqueInput>
    update?: Enumerable<SentEmailUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<SentEmailUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<SentEmailScalarWhereInput>
  }

  export type DomainUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<DomainCreateWithoutProjectInput>, Enumerable<DomainUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<DomainCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<DomainUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: DomainCreateManyProjectInputEnvelope
    set?: Enumerable<DomainWhereUniqueInput>
    disconnect?: Enumerable<DomainWhereUniqueInput>
    delete?: Enumerable<DomainWhereUniqueInput>
    connect?: Enumerable<DomainWhereUniqueInput>
    update?: Enumerable<DomainUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<DomainUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<DomainScalarWhereInput>
  }

  export type LinkUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutProjectInput>, Enumerable<LinkUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: LinkCreateManyProjectInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type TagUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<Enumerable<TagCreateWithoutProjectInput>, Enumerable<TagUncheckedCreateWithoutProjectInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutProjectInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutProjectInput>
    createMany?: TagCreateManyProjectInputEnvelope
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutProjectInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutProjectInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type ProjectCreateNestedOneWithoutInvitesInput = {
    create?: XOR<ProjectCreateWithoutInvitesInput, ProjectUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvitesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<ProjectCreateWithoutInvitesInput, ProjectUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvitesInput
    upsert?: ProjectUpsertWithoutInvitesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutInvitesInput, ProjectUncheckedUpdateWithoutInvitesInput>
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutUsersInput = {
    create?: XOR<ProjectCreateWithoutUsersInput, ProjectUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUsersInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ProjectCreateWithoutUsersInput, ProjectUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUsersInput
    upsert?: ProjectUpsertWithoutUsersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutUsersInput, ProjectUncheckedUpdateWithoutUsersInput>
  }

  export type ProjectCreateNestedOneWithoutSentEmailsInput = {
    create?: XOR<ProjectCreateWithoutSentEmailsInput, ProjectUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSentEmailsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumEmailTypeFieldUpdateOperationsInput = {
    set?: EmailType
  }

  export type ProjectUpdateOneWithoutSentEmailsNestedInput = {
    create?: XOR<ProjectCreateWithoutSentEmailsInput, ProjectUncheckedCreateWithoutSentEmailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSentEmailsInput
    upsert?: ProjectUpsertWithoutSentEmailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutSentEmailsInput, ProjectUncheckedUpdateWithoutSentEmailsInput>
  }

  export type ProjectCreateNestedOneWithoutDomainsInput = {
    create?: XOR<ProjectCreateWithoutDomainsInput, ProjectUncheckedCreateWithoutDomainsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDomainsInput
    connect?: ProjectWhereUniqueInput
  }

  export type LinkCreateNestedManyWithoutProjectDomainInput = {
    create?: XOR<Enumerable<LinkCreateWithoutProjectDomainInput>, Enumerable<LinkUncheckedCreateWithoutProjectDomainInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutProjectDomainInput>
    createMany?: LinkCreateManyProjectDomainInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type LinkUncheckedCreateNestedManyWithoutProjectDomainInput = {
    create?: XOR<Enumerable<LinkCreateWithoutProjectDomainInput>, Enumerable<LinkUncheckedCreateWithoutProjectDomainInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutProjectDomainInput>
    createMany?: LinkCreateManyProjectDomainInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type ProjectUpdateOneWithoutDomainsNestedInput = {
    create?: XOR<ProjectCreateWithoutDomainsInput, ProjectUncheckedCreateWithoutDomainsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDomainsInput
    upsert?: ProjectUpsertWithoutDomainsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutDomainsInput, ProjectUncheckedUpdateWithoutDomainsInput>
  }

  export type LinkUpdateManyWithoutProjectDomainNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutProjectDomainInput>, Enumerable<LinkUncheckedCreateWithoutProjectDomainInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutProjectDomainInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutProjectDomainInput>
    createMany?: LinkCreateManyProjectDomainInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutProjectDomainInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutProjectDomainInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type LinkUncheckedUpdateManyWithoutProjectDomainNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutProjectDomainInput>, Enumerable<LinkUncheckedCreateWithoutProjectDomainInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutProjectDomainInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutProjectDomainInput>
    createMany?: LinkCreateManyProjectDomainInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutProjectDomainInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutProjectDomainInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutLinksInput = {
    create?: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinksInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutLinksInput = {
    create?: XOR<ProjectCreateWithoutLinksInput, ProjectUncheckedCreateWithoutLinksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLinksInput
    connect?: ProjectWhereUniqueInput
  }

  export type DomainCreateNestedOneWithoutLinksInput = {
    create?: XOR<DomainCreateWithoutLinksInput, DomainUncheckedCreateWithoutLinksInput>
    connectOrCreate?: DomainCreateOrConnectWithoutLinksInput
    connect?: DomainWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutLinksInput = {
    create?: XOR<TagCreateWithoutLinksInput, TagUncheckedCreateWithoutLinksInput>
    connectOrCreate?: TagCreateOrConnectWithoutLinksInput
    connect?: TagWhereUniqueInput
  }

  export type UserUpdateOneWithoutLinksNestedInput = {
    create?: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinksInput
    upsert?: UserUpsertWithoutLinksInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLinksInput, UserUncheckedUpdateWithoutLinksInput>
  }

  export type ProjectUpdateOneWithoutLinksNestedInput = {
    create?: XOR<ProjectCreateWithoutLinksInput, ProjectUncheckedCreateWithoutLinksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLinksInput
    upsert?: ProjectUpsertWithoutLinksInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutLinksInput, ProjectUncheckedUpdateWithoutLinksInput>
  }

  export type DomainUpdateOneWithoutLinksNestedInput = {
    create?: XOR<DomainCreateWithoutLinksInput, DomainUncheckedCreateWithoutLinksInput>
    connectOrCreate?: DomainCreateOrConnectWithoutLinksInput
    upsert?: DomainUpsertWithoutLinksInput
    disconnect?: boolean
    delete?: boolean
    connect?: DomainWhereUniqueInput
    update?: XOR<DomainUpdateWithoutLinksInput, DomainUncheckedUpdateWithoutLinksInput>
  }

  export type TagUpdateOneWithoutLinksNestedInput = {
    create?: XOR<TagCreateWithoutLinksInput, TagUncheckedCreateWithoutLinksInput>
    connectOrCreate?: TagCreateOrConnectWithoutLinksInput
    upsert?: TagUpsertWithoutLinksInput
    disconnect?: boolean
    delete?: boolean
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutLinksInput, TagUncheckedUpdateWithoutLinksInput>
  }

  export type ProjectCreateNestedOneWithoutTagsInput = {
    create?: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTagsInput
    connect?: ProjectWhereUniqueInput
  }

  export type LinkCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<LinkCreateWithoutTagInput>, Enumerable<LinkUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutTagInput>
    createMany?: LinkCreateManyTagInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type LinkUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<LinkCreateWithoutTagInput>, Enumerable<LinkUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutTagInput>
    createMany?: LinkCreateManyTagInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type ProjectUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTagsInput
    upsert?: ProjectUpsertWithoutTagsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<ProjectUpdateWithoutTagsInput, ProjectUncheckedUpdateWithoutTagsInput>
  }

  export type LinkUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutTagInput>, Enumerable<LinkUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutTagInput>
    createMany?: LinkCreateManyTagInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type LinkUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutTagInput>, Enumerable<LinkUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutTagInput>
    createMany?: LinkCreateManyTagInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedEnumEmailTypeFilter = {
    equals?: EmailType
    in?: Enumerable<EmailType>
    notIn?: Enumerable<EmailType>
    not?: NestedEnumEmailTypeFilter | EmailType
  }

  export type NestedEnumEmailTypeWithAggregatesFilter = {
    equals?: EmailType
    in?: Enumerable<EmailType>
    notIn?: Enumerable<EmailType>
    not?: NestedEnumEmailTypeWithAggregatesFilter | EmailType
    _count?: NestedIntFilter
    _min?: NestedEnumEmailTypeFilter
    _max?: NestedEnumEmailTypeFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type SiteCreateWithoutSiteTemplateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    slotData?: JsonNullValueInput | InputJsonValue
    customer: CustomerCreateNestedOneWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutSiteTemplateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    customerId: number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteCreateOrConnectWithoutSiteTemplateInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutSiteTemplateInput, SiteUncheckedCreateWithoutSiteTemplateInput>
  }

  export type SiteCreateManySiteTemplateInputEnvelope = {
    data: Enumerable<SiteCreateManySiteTemplateInput>
    skipDuplicates?: boolean
  }

  export type SiteTemplateDataDefCreateWithoutSiteTemplateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    defData: JsonNullValueInput | InputJsonValue
  }

  export type SiteTemplateDataDefUncheckedCreateWithoutSiteTemplateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    defData: JsonNullValueInput | InputJsonValue
  }

  export type SiteTemplateDataDefCreateOrConnectWithoutSiteTemplateInput = {
    where: SiteTemplateDataDefWhereUniqueInput
    create: XOR<SiteTemplateDataDefCreateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedCreateWithoutSiteTemplateInput>
  }

  export type SiteUpsertWithWhereUniqueWithoutSiteTemplateInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutSiteTemplateInput, SiteUncheckedUpdateWithoutSiteTemplateInput>
    create: XOR<SiteCreateWithoutSiteTemplateInput, SiteUncheckedCreateWithoutSiteTemplateInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutSiteTemplateInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutSiteTemplateInput, SiteUncheckedUpdateWithoutSiteTemplateInput>
  }

  export type SiteUpdateManyWithWhereWithoutSiteTemplateInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutSiteInput>
  }

  export type SiteScalarWhereInput = {
    AND?: Enumerable<SiteScalarWhereInput>
    OR?: Enumerable<SiteScalarWhereInput>
    NOT?: Enumerable<SiteScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    cosUrl?: StringFilter | string
    siteTemplateId?: IntFilter | number
    customerId?: IntFilter | number
    slotData?: JsonFilter
  }

  export type SiteTemplateDataDefUpsertWithoutSiteTemplateInput = {
    update: XOR<SiteTemplateDataDefUpdateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedUpdateWithoutSiteTemplateInput>
    create: XOR<SiteTemplateDataDefCreateWithoutSiteTemplateInput, SiteTemplateDataDefUncheckedCreateWithoutSiteTemplateInput>
  }

  export type SiteTemplateDataDefUpdateWithoutSiteTemplateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    defData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteTemplateDataDefUncheckedUpdateWithoutSiteTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    defData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteTemplateCreateWithoutSiteTemplateDataDefInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    template: string
    site?: SiteCreateNestedManyWithoutSiteTemplateInput
  }

  export type SiteTemplateUncheckedCreateWithoutSiteTemplateDataDefInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    template: string
    site?: SiteUncheckedCreateNestedManyWithoutSiteTemplateInput
  }

  export type SiteTemplateCreateOrConnectWithoutSiteTemplateDataDefInput = {
    where: SiteTemplateWhereUniqueInput
    create: XOR<SiteTemplateCreateWithoutSiteTemplateDataDefInput, SiteTemplateUncheckedCreateWithoutSiteTemplateDataDefInput>
  }

  export type SiteTemplateUpsertWithoutSiteTemplateDataDefInput = {
    update: XOR<SiteTemplateUpdateWithoutSiteTemplateDataDefInput, SiteTemplateUncheckedUpdateWithoutSiteTemplateDataDefInput>
    create: XOR<SiteTemplateCreateWithoutSiteTemplateDataDefInput, SiteTemplateUncheckedCreateWithoutSiteTemplateDataDefInput>
  }

  export type SiteTemplateUpdateWithoutSiteTemplateDataDefInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    site?: SiteUpdateManyWithoutSiteTemplateNestedInput
  }

  export type SiteTemplateUncheckedUpdateWithoutSiteTemplateDataDefInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    site?: SiteUncheckedUpdateManyWithoutSiteTemplateNestedInput
  }

  export type SiteCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    slotData?: JsonNullValueInput | InputJsonValue
    siteTemplate: SiteTemplateCreateNestedOneWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutCustomerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    siteTemplateId: number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteCreateOrConnectWithoutCustomerInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutCustomerInput, SiteUncheckedCreateWithoutCustomerInput>
  }

  export type SiteCreateManyCustomerInputEnvelope = {
    data: Enumerable<SiteCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type SiteUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutCustomerInput, SiteUncheckedUpdateWithoutCustomerInput>
    create: XOR<SiteCreateWithoutCustomerInput, SiteUncheckedCreateWithoutCustomerInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutCustomerInput, SiteUncheckedUpdateWithoutCustomerInput>
  }

  export type SiteUpdateManyWithWhereWithoutCustomerInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutSiteInput>
  }

  export type SiteTemplateCreateWithoutSiteInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    template: string
    siteTemplateDataDef?: SiteTemplateDataDefCreateNestedOneWithoutSiteTemplateInput
  }

  export type SiteTemplateUncheckedCreateWithoutSiteInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    template: string
    siteTemplateDataDef?: SiteTemplateDataDefUncheckedCreateNestedOneWithoutSiteTemplateInput
  }

  export type SiteTemplateCreateOrConnectWithoutSiteInput = {
    where: SiteTemplateWhereUniqueInput
    create: XOR<SiteTemplateCreateWithoutSiteInput, SiteTemplateUncheckedCreateWithoutSiteInput>
  }

  export type CustomerCreateWithoutSiteInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerUncheckedCreateWithoutSiteInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerCreateOrConnectWithoutSiteInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSiteInput, CustomerUncheckedCreateWithoutSiteInput>
  }

  export type SiteTemplateUpsertWithoutSiteInput = {
    update: XOR<SiteTemplateUpdateWithoutSiteInput, SiteTemplateUncheckedUpdateWithoutSiteInput>
    create: XOR<SiteTemplateCreateWithoutSiteInput, SiteTemplateUncheckedCreateWithoutSiteInput>
  }

  export type SiteTemplateUpdateWithoutSiteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    siteTemplateDataDef?: SiteTemplateDataDefUpdateOneWithoutSiteTemplateNestedInput
  }

  export type SiteTemplateUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    siteTemplateDataDef?: SiteTemplateDataDefUncheckedUpdateOneWithoutSiteTemplateNestedInput
  }

  export type CustomerUpsertWithoutSiteInput = {
    update: XOR<CustomerUpdateWithoutSiteInput, CustomerUncheckedUpdateWithoutSiteInput>
    create: XOR<CustomerCreateWithoutSiteInput, CustomerUncheckedCreateWithoutSiteInput>
  }

  export type CustomerUpdateWithoutSiteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerUncheckedUpdateWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    extendData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: Enumerable<SessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProjectUsersCreateWithoutUserInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUsersInput
  }

  export type ProjectUsersUncheckedCreateWithoutUserInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ProjectUsersCreateOrConnectWithoutUserInput = {
    where: ProjectUsersWhereUniqueInput
    create: XOR<ProjectUsersCreateWithoutUserInput, ProjectUsersUncheckedCreateWithoutUserInput>
  }

  export type ProjectUsersCreateManyUserInputEnvelope = {
    data: Enumerable<ProjectUsersCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LinkCreateWithoutUserInput = {
    id?: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutLinksInput
    projectDomain?: DomainCreateNestedOneWithoutLinksInput
    tag?: TagCreateNestedOneWithoutLinksInput
  }

  export type LinkUncheckedCreateWithoutUserInput = {
    id?: string
    domain: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    projectId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tagId?: string | null
  }

  export type LinkCreateOrConnectWithoutUserInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutUserInput, LinkUncheckedCreateWithoutUserInput>
  }

  export type LinkCreateManyUserInputEnvelope = {
    data: Enumerable<LinkCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    refresh_token_expires_in?: IntNullableFilter | number | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type ProjectUsersUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectUsersWhereUniqueInput
    update: XOR<ProjectUsersUpdateWithoutUserInput, ProjectUsersUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectUsersCreateWithoutUserInput, ProjectUsersUncheckedCreateWithoutUserInput>
  }

  export type ProjectUsersUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectUsersWhereUniqueInput
    data: XOR<ProjectUsersUpdateWithoutUserInput, ProjectUsersUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUsersUpdateManyWithWhereWithoutUserInput = {
    where: ProjectUsersScalarWhereInput
    data: XOR<ProjectUsersUpdateManyMutationInput, ProjectUsersUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectUsersScalarWhereInput = {
    AND?: Enumerable<ProjectUsersScalarWhereInput>
    OR?: Enumerable<ProjectUsersScalarWhereInput>
    NOT?: Enumerable<ProjectUsersScalarWhereInput>
    id?: StringFilter | string
    role?: EnumRoleFilter | Role
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    projectId?: StringFilter | string
  }

  export type LinkUpsertWithWhereUniqueWithoutUserInput = {
    where: LinkWhereUniqueInput
    update: XOR<LinkUpdateWithoutUserInput, LinkUncheckedUpdateWithoutUserInput>
    create: XOR<LinkCreateWithoutUserInput, LinkUncheckedCreateWithoutUserInput>
  }

  export type LinkUpdateWithWhereUniqueWithoutUserInput = {
    where: LinkWhereUniqueInput
    data: XOR<LinkUpdateWithoutUserInput, LinkUncheckedUpdateWithoutUserInput>
  }

  export type LinkUpdateManyWithWhereWithoutUserInput = {
    where: LinkScalarWhereInput
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyWithoutLinksInput>
  }

  export type LinkScalarWhereInput = {
    AND?: Enumerable<LinkScalarWhereInput>
    OR?: Enumerable<LinkScalarWhereInput>
    NOT?: Enumerable<LinkScalarWhereInput>
    id?: StringFilter | string
    domain?: StringFilter | string
    key?: StringFilter | string
    url?: StringFilter | string
    archived?: BoolFilter | boolean
    expiresAt?: DateTimeNullableFilter | Date | string | null
    password?: StringNullableFilter | string | null
    proxy?: BoolFilter | boolean
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    utm_source?: StringNullableFilter | string | null
    utm_medium?: StringNullableFilter | string | null
    utm_campaign?: StringNullableFilter | string | null
    utm_term?: StringNullableFilter | string | null
    utm_content?: StringNullableFilter | string | null
    rewrite?: BoolFilter | boolean
    ios?: StringNullableFilter | string | null
    android?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    projectId?: StringNullableFilter | string | null
    clicks?: IntFilter | number
    publicStats?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    tagId?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    projects?: ProjectUsersCreateNestedManyWithoutUserInput
    links?: LinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUsersUncheckedCreateNestedManyWithoutUserInput
    links?: LinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    projects?: ProjectUsersUpdateManyWithoutUserNestedInput
    links?: LinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUsersUncheckedUpdateManyWithoutUserNestedInput
    links?: LinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    projects?: ProjectUsersCreateNestedManyWithoutUserInput
    links?: LinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUsersUncheckedCreateNestedManyWithoutUserInput
    links?: LinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    projects?: ProjectUsersUpdateManyWithoutUserNestedInput
    links?: LinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUsersUncheckedUpdateManyWithoutUserNestedInput
    links?: LinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUsersCreateWithoutProjectInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUsersUncheckedCreateWithoutProjectInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ProjectUsersCreateOrConnectWithoutProjectInput = {
    where: ProjectUsersWhereUniqueInput
    create: XOR<ProjectUsersCreateWithoutProjectInput, ProjectUsersUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUsersCreateManyProjectInputEnvelope = {
    data: Enumerable<ProjectUsersCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type ProjectInviteCreateWithoutProjectInput = {
    email: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type ProjectInviteUncheckedCreateWithoutProjectInput = {
    email: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type ProjectInviteCreateOrConnectWithoutProjectInput = {
    where: ProjectInviteWhereUniqueInput
    create: XOR<ProjectInviteCreateWithoutProjectInput, ProjectInviteUncheckedCreateWithoutProjectInput>
  }

  export type ProjectInviteCreateManyProjectInputEnvelope = {
    data: Enumerable<ProjectInviteCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type SentEmailCreateWithoutProjectInput = {
    id?: string
    type: EmailType
    createdAt?: Date | string
  }

  export type SentEmailUncheckedCreateWithoutProjectInput = {
    id?: string
    type: EmailType
    createdAt?: Date | string
  }

  export type SentEmailCreateOrConnectWithoutProjectInput = {
    where: SentEmailWhereUniqueInput
    create: XOR<SentEmailCreateWithoutProjectInput, SentEmailUncheckedCreateWithoutProjectInput>
  }

  export type SentEmailCreateManyProjectInputEnvelope = {
    data: Enumerable<SentEmailCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type DomainCreateWithoutProjectInput = {
    id?: string
    slug: string
    verified?: boolean
    target?: string | null
    type?: string
    description?: string | null
    primary?: boolean
    lastChecked?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: LinkCreateNestedManyWithoutProjectDomainInput
  }

  export type DomainUncheckedCreateWithoutProjectInput = {
    id?: string
    slug: string
    verified?: boolean
    target?: string | null
    type?: string
    description?: string | null
    primary?: boolean
    lastChecked?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: LinkUncheckedCreateNestedManyWithoutProjectDomainInput
  }

  export type DomainCreateOrConnectWithoutProjectInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutProjectInput, DomainUncheckedCreateWithoutProjectInput>
  }

  export type DomainCreateManyProjectInputEnvelope = {
    data: Enumerable<DomainCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type LinkCreateWithoutProjectInput = {
    id?: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutLinksInput
    projectDomain?: DomainCreateNestedOneWithoutLinksInput
    tag?: TagCreateNestedOneWithoutLinksInput
  }

  export type LinkUncheckedCreateWithoutProjectInput = {
    id?: string
    domain: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    userId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tagId?: string | null
  }

  export type LinkCreateOrConnectWithoutProjectInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutProjectInput, LinkUncheckedCreateWithoutProjectInput>
  }

  export type LinkCreateManyProjectInputEnvelope = {
    data: Enumerable<LinkCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutProjectInput = {
    id?: string
    name: string
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: LinkCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: LinkUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutProjectInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput>
  }

  export type TagCreateManyProjectInputEnvelope = {
    data: Enumerable<TagCreateManyProjectInput>
    skipDuplicates?: boolean
  }

  export type ProjectUsersUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectUsersWhereUniqueInput
    update: XOR<ProjectUsersUpdateWithoutProjectInput, ProjectUsersUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectUsersCreateWithoutProjectInput, ProjectUsersUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUsersUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectUsersWhereUniqueInput
    data: XOR<ProjectUsersUpdateWithoutProjectInput, ProjectUsersUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectUsersUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectUsersScalarWhereInput
    data: XOR<ProjectUsersUpdateManyMutationInput, ProjectUsersUncheckedUpdateManyWithoutUsersInput>
  }

  export type ProjectInviteUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectInviteWhereUniqueInput
    update: XOR<ProjectInviteUpdateWithoutProjectInput, ProjectInviteUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectInviteCreateWithoutProjectInput, ProjectInviteUncheckedCreateWithoutProjectInput>
  }

  export type ProjectInviteUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectInviteWhereUniqueInput
    data: XOR<ProjectInviteUpdateWithoutProjectInput, ProjectInviteUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectInviteUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectInviteScalarWhereInput
    data: XOR<ProjectInviteUpdateManyMutationInput, ProjectInviteUncheckedUpdateManyWithoutInvitesInput>
  }

  export type ProjectInviteScalarWhereInput = {
    AND?: Enumerable<ProjectInviteScalarWhereInput>
    OR?: Enumerable<ProjectInviteScalarWhereInput>
    NOT?: Enumerable<ProjectInviteScalarWhereInput>
    email?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    projectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type SentEmailUpsertWithWhereUniqueWithoutProjectInput = {
    where: SentEmailWhereUniqueInput
    update: XOR<SentEmailUpdateWithoutProjectInput, SentEmailUncheckedUpdateWithoutProjectInput>
    create: XOR<SentEmailCreateWithoutProjectInput, SentEmailUncheckedCreateWithoutProjectInput>
  }

  export type SentEmailUpdateWithWhereUniqueWithoutProjectInput = {
    where: SentEmailWhereUniqueInput
    data: XOR<SentEmailUpdateWithoutProjectInput, SentEmailUncheckedUpdateWithoutProjectInput>
  }

  export type SentEmailUpdateManyWithWhereWithoutProjectInput = {
    where: SentEmailScalarWhereInput
    data: XOR<SentEmailUpdateManyMutationInput, SentEmailUncheckedUpdateManyWithoutSentEmailsInput>
  }

  export type SentEmailScalarWhereInput = {
    AND?: Enumerable<SentEmailScalarWhereInput>
    OR?: Enumerable<SentEmailScalarWhereInput>
    NOT?: Enumerable<SentEmailScalarWhereInput>
    id?: StringFilter | string
    type?: EnumEmailTypeFilter | EmailType
    createdAt?: DateTimeFilter | Date | string
    projectId?: StringNullableFilter | string | null
  }

  export type DomainUpsertWithWhereUniqueWithoutProjectInput = {
    where: DomainWhereUniqueInput
    update: XOR<DomainUpdateWithoutProjectInput, DomainUncheckedUpdateWithoutProjectInput>
    create: XOR<DomainCreateWithoutProjectInput, DomainUncheckedCreateWithoutProjectInput>
  }

  export type DomainUpdateWithWhereUniqueWithoutProjectInput = {
    where: DomainWhereUniqueInput
    data: XOR<DomainUpdateWithoutProjectInput, DomainUncheckedUpdateWithoutProjectInput>
  }

  export type DomainUpdateManyWithWhereWithoutProjectInput = {
    where: DomainScalarWhereInput
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyWithoutDomainsInput>
  }

  export type DomainScalarWhereInput = {
    AND?: Enumerable<DomainScalarWhereInput>
    OR?: Enumerable<DomainScalarWhereInput>
    NOT?: Enumerable<DomainScalarWhereInput>
    id?: StringFilter | string
    slug?: StringFilter | string
    verified?: BoolFilter | boolean
    target?: StringNullableFilter | string | null
    type?: StringFilter | string
    description?: StringNullableFilter | string | null
    projectId?: StringNullableFilter | string | null
    primary?: BoolFilter | boolean
    lastChecked?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LinkUpsertWithWhereUniqueWithoutProjectInput = {
    where: LinkWhereUniqueInput
    update: XOR<LinkUpdateWithoutProjectInput, LinkUncheckedUpdateWithoutProjectInput>
    create: XOR<LinkCreateWithoutProjectInput, LinkUncheckedCreateWithoutProjectInput>
  }

  export type LinkUpdateWithWhereUniqueWithoutProjectInput = {
    where: LinkWhereUniqueInput
    data: XOR<LinkUpdateWithoutProjectInput, LinkUncheckedUpdateWithoutProjectInput>
  }

  export type LinkUpdateManyWithWhereWithoutProjectInput = {
    where: LinkScalarWhereInput
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyWithoutLinksInput>
  }

  export type TagUpsertWithWhereUniqueWithoutProjectInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutProjectInput, TagUncheckedUpdateWithoutProjectInput>
    create: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput>
  }

  export type TagUpdateWithWhereUniqueWithoutProjectInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutProjectInput, TagUncheckedUpdateWithoutProjectInput>
  }

  export type TagUpdateManyWithWhereWithoutProjectInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTagsInput>
  }

  export type TagScalarWhereInput = {
    AND?: Enumerable<TagScalarWhereInput>
    OR?: Enumerable<TagScalarWhereInput>
    NOT?: Enumerable<TagScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    color?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    projectId?: StringFilter | string
  }

  export type ProjectCreateWithoutInvitesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailCreateNestedManyWithoutProjectInput
    domains?: DomainCreateNestedManyWithoutProjectInput
    links?: LinkCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersUncheckedCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutProjectInput
    domains?: DomainUncheckedCreateNestedManyWithoutProjectInput
    links?: LinkUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInvitesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInvitesInput, ProjectUncheckedCreateWithoutInvitesInput>
  }

  export type ProjectUpsertWithoutInvitesInput = {
    update: XOR<ProjectUpdateWithoutInvitesInput, ProjectUncheckedUpdateWithoutInvitesInput>
    create: XOR<ProjectCreateWithoutInvitesInput, ProjectUncheckedCreateWithoutInvitesInput>
  }

  export type ProjectUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUpdateManyWithoutProjectNestedInput
    domains?: DomainUpdateManyWithoutProjectNestedInput
    links?: LinkUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUncheckedUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutProjectNestedInput
    domains?: DomainUncheckedUpdateManyWithoutProjectNestedInput
    links?: LinkUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    links?: LinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    links?: LinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailCreateNestedManyWithoutProjectInput
    domains?: DomainCreateNestedManyWithoutProjectInput
    links?: LinkCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutProjectInput
    domains?: DomainUncheckedCreateNestedManyWithoutProjectInput
    links?: LinkUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUsersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUsersInput, ProjectUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    links?: LinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    links?: LinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutUsersInput = {
    update: XOR<ProjectUpdateWithoutUsersInput, ProjectUncheckedUpdateWithoutUsersInput>
    create: XOR<ProjectCreateWithoutUsersInput, ProjectUncheckedCreateWithoutUsersInput>
  }

  export type ProjectUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUpdateManyWithoutProjectNestedInput
    domains?: DomainUpdateManyWithoutProjectNestedInput
    links?: LinkUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutProjectNestedInput
    domains?: DomainUncheckedUpdateManyWithoutProjectNestedInput
    links?: LinkUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    domains?: DomainCreateNestedManyWithoutProjectInput
    links?: LinkCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSentEmailsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    domains?: DomainUncheckedCreateNestedManyWithoutProjectInput
    links?: LinkUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSentEmailsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSentEmailsInput, ProjectUncheckedCreateWithoutSentEmailsInput>
  }

  export type ProjectUpsertWithoutSentEmailsInput = {
    update: XOR<ProjectUpdateWithoutSentEmailsInput, ProjectUncheckedUpdateWithoutSentEmailsInput>
    create: XOR<ProjectCreateWithoutSentEmailsInput, ProjectUncheckedCreateWithoutSentEmailsInput>
  }

  export type ProjectUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    domains?: DomainUpdateManyWithoutProjectNestedInput
    links?: LinkUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    domains?: DomainUncheckedUpdateManyWithoutProjectNestedInput
    links?: LinkUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutDomainsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailCreateNestedManyWithoutProjectInput
    links?: LinkCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDomainsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutProjectInput
    links?: LinkUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDomainsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDomainsInput, ProjectUncheckedCreateWithoutDomainsInput>
  }

  export type LinkCreateWithoutProjectDomainInput = {
    id?: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutLinksInput
    project?: ProjectCreateNestedOneWithoutLinksInput
    tag?: TagCreateNestedOneWithoutLinksInput
  }

  export type LinkUncheckedCreateWithoutProjectDomainInput = {
    id?: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    userId?: string | null
    projectId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tagId?: string | null
  }

  export type LinkCreateOrConnectWithoutProjectDomainInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutProjectDomainInput, LinkUncheckedCreateWithoutProjectDomainInput>
  }

  export type LinkCreateManyProjectDomainInputEnvelope = {
    data: Enumerable<LinkCreateManyProjectDomainInput>
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutDomainsInput = {
    update: XOR<ProjectUpdateWithoutDomainsInput, ProjectUncheckedUpdateWithoutDomainsInput>
    create: XOR<ProjectCreateWithoutDomainsInput, ProjectUncheckedCreateWithoutDomainsInput>
  }

  export type ProjectUpdateWithoutDomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUpdateManyWithoutProjectNestedInput
    links?: LinkUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutProjectNestedInput
    links?: LinkUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type LinkUpsertWithWhereUniqueWithoutProjectDomainInput = {
    where: LinkWhereUniqueInput
    update: XOR<LinkUpdateWithoutProjectDomainInput, LinkUncheckedUpdateWithoutProjectDomainInput>
    create: XOR<LinkCreateWithoutProjectDomainInput, LinkUncheckedCreateWithoutProjectDomainInput>
  }

  export type LinkUpdateWithWhereUniqueWithoutProjectDomainInput = {
    where: LinkWhereUniqueInput
    data: XOR<LinkUpdateWithoutProjectDomainInput, LinkUncheckedUpdateWithoutProjectDomainInput>
  }

  export type LinkUpdateManyWithWhereWithoutProjectDomainInput = {
    where: LinkScalarWhereInput
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyWithoutLinksInput>
  }

  export type UserCreateWithoutLinksInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    projects?: ProjectUsersCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLinksInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUsersUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
  }

  export type ProjectCreateWithoutLinksInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailCreateNestedManyWithoutProjectInput
    domains?: DomainCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLinksInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutProjectInput
    domains?: DomainUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLinksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLinksInput, ProjectUncheckedCreateWithoutLinksInput>
  }

  export type DomainCreateWithoutLinksInput = {
    id?: string
    slug: string
    verified?: boolean
    target?: string | null
    type?: string
    description?: string | null
    primary?: boolean
    lastChecked?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutDomainsInput
  }

  export type DomainUncheckedCreateWithoutLinksInput = {
    id?: string
    slug: string
    verified?: boolean
    target?: string | null
    type?: string
    description?: string | null
    projectId?: string | null
    primary?: boolean
    lastChecked?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainCreateOrConnectWithoutLinksInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutLinksInput, DomainUncheckedCreateWithoutLinksInput>
  }

  export type TagCreateWithoutLinksInput = {
    id?: string
    name: string
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutLinksInput = {
    id?: string
    name: string
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type TagCreateOrConnectWithoutLinksInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutLinksInput, TagUncheckedCreateWithoutLinksInput>
  }

  export type UserUpsertWithoutLinksInput = {
    update: XOR<UserUpdateWithoutLinksInput, UserUncheckedUpdateWithoutLinksInput>
    create: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
  }

  export type UserUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    projects?: ProjectUsersUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUsersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutLinksInput = {
    update: XOR<ProjectUpdateWithoutLinksInput, ProjectUncheckedUpdateWithoutLinksInput>
    create: XOR<ProjectCreateWithoutLinksInput, ProjectUncheckedCreateWithoutLinksInput>
  }

  export type ProjectUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUpdateManyWithoutProjectNestedInput
    domains?: DomainUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutProjectNestedInput
    domains?: DomainUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DomainUpsertWithoutLinksInput = {
    update: XOR<DomainUpdateWithoutLinksInput, DomainUncheckedUpdateWithoutLinksInput>
    create: XOR<DomainCreateWithoutLinksInput, DomainUncheckedCreateWithoutLinksInput>
  }

  export type DomainUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutDomainsNestedInput
  }

  export type DomainUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpsertWithoutLinksInput = {
    update: XOR<TagUpdateWithoutLinksInput, TagUncheckedUpdateWithoutLinksInput>
    create: XOR<TagCreateWithoutLinksInput, TagUncheckedCreateWithoutLinksInput>
  }

  export type TagUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateWithoutTagsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailCreateNestedManyWithoutProjectInput
    domains?: DomainCreateNestedManyWithoutProjectInput
    links?: LinkCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    password?: string | null
    type?: string
    usage?: number
    usageLimit?: number
    plan?: string
    stripeId?: string | null
    billingCycleStart?: number | null
    region?: string | null
    endpoint?: string | null
    bucket?: string | null
    useHost?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    users?: ProjectUsersUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    sentEmails?: SentEmailUncheckedCreateNestedManyWithoutProjectInput
    domains?: DomainUncheckedCreateNestedManyWithoutProjectInput
    links?: LinkUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTagsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
  }

  export type LinkCreateWithoutTagInput = {
    id?: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutLinksInput
    project?: ProjectCreateNestedOneWithoutLinksInput
    projectDomain?: DomainCreateNestedOneWithoutLinksInput
  }

  export type LinkUncheckedCreateWithoutTagInput = {
    id?: string
    domain: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    userId?: string | null
    projectId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkCreateOrConnectWithoutTagInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutTagInput, LinkUncheckedCreateWithoutTagInput>
  }

  export type LinkCreateManyTagInputEnvelope = {
    data: Enumerable<LinkCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutTagsInput = {
    update: XOR<ProjectUpdateWithoutTagsInput, ProjectUncheckedUpdateWithoutTagsInput>
    create: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
  }

  export type ProjectUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUpdateManyWithoutProjectNestedInput
    domains?: DomainUpdateManyWithoutProjectNestedInput
    links?: LinkUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    usage?: IntFieldUpdateOperationsInput | number
    usageLimit?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    billingCycleStart?: NullableIntFieldUpdateOperationsInput | number | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    useHost?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    users?: ProjectUsersUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    sentEmails?: SentEmailUncheckedUpdateManyWithoutProjectNestedInput
    domains?: DomainUncheckedUpdateManyWithoutProjectNestedInput
    links?: LinkUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type LinkUpsertWithWhereUniqueWithoutTagInput = {
    where: LinkWhereUniqueInput
    update: XOR<LinkUpdateWithoutTagInput, LinkUncheckedUpdateWithoutTagInput>
    create: XOR<LinkCreateWithoutTagInput, LinkUncheckedCreateWithoutTagInput>
  }

  export type LinkUpdateWithWhereUniqueWithoutTagInput = {
    where: LinkWhereUniqueInput
    data: XOR<LinkUpdateWithoutTagInput, LinkUncheckedUpdateWithoutTagInput>
  }

  export type LinkUpdateManyWithWhereWithoutTagInput = {
    where: LinkScalarWhereInput
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyWithoutLinksInput>
  }

  export type SiteCreateManySiteTemplateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    customerId: number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteUpdateWithoutSiteTemplateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    slotData?: JsonNullValueInput | InputJsonValue
    customer?: CustomerUpdateOneRequiredWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutSiteTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteUncheckedUpdateManyWithoutSiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteCreateManyCustomerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    cosUrl?: string
    siteTemplateId: number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type SiteUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    slotData?: JsonNullValueInput | InputJsonValue
    siteTemplate?: SiteTemplateUpdateOneRequiredWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    cosUrl?: StringFieldUpdateOperationsInput | string
    siteTemplateId?: IntFieldUpdateOperationsInput | number
    slotData?: JsonNullValueInput | InputJsonValue
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type ProjectUsersCreateManyUserInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type LinkCreateManyUserInput = {
    id?: string
    domain: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    projectId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tagId?: string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUsersUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ProjectUsersUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUsersUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type LinkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutLinksNestedInput
    projectDomain?: DomainUpdateOneWithoutLinksNestedInput
    tag?: TagUpdateOneWithoutLinksNestedInput
  }

  export type LinkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LinkUncheckedUpdateManyWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUsersCreateManyProjectInput = {
    id?: string
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ProjectInviteCreateManyProjectInput = {
    email: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SentEmailCreateManyProjectInput = {
    id?: string
    type: EmailType
    createdAt?: Date | string
  }

  export type DomainCreateManyProjectInput = {
    id?: string
    slug: string
    verified?: boolean
    target?: string | null
    type?: string
    description?: string | null
    primary?: boolean
    lastChecked?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkCreateManyProjectInput = {
    id?: string
    domain: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    userId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tagId?: string | null
  }

  export type TagCreateManyProjectInput = {
    id?: string
    name: string
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUsersUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUsersUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUsersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectInviteUpdateWithoutProjectInput = {
    email?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteUncheckedUpdateWithoutProjectInput = {
    email?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteUncheckedUpdateManyWithoutInvitesInput = {
    email?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | EmailType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | EmailType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SentEmailUncheckedUpdateManyWithoutSentEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | EmailType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: LinkUpdateManyWithoutProjectDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: LinkUncheckedUpdateManyWithoutProjectDomainNestedInput
  }

  export type DomainUncheckedUpdateManyWithoutDomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    target?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLinksNestedInput
    projectDomain?: DomainUpdateOneWithoutLinksNestedInput
    tag?: TagUpdateOneWithoutLinksNestedInput
  }

  export type LinkUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: LinkUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: LinkUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkCreateManyProjectDomainInput = {
    id?: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    userId?: string | null
    projectId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tagId?: string | null
  }

  export type LinkUpdateWithoutProjectDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLinksNestedInput
    project?: ProjectUpdateOneWithoutLinksNestedInput
    tag?: TagUpdateOneWithoutLinksNestedInput
  }

  export type LinkUncheckedUpdateWithoutProjectDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LinkCreateManyTagInput = {
    id?: string
    domain: string
    key: string
    url: string
    archived?: boolean
    expiresAt?: Date | string | null
    password?: string | null
    proxy?: boolean
    title?: string | null
    description?: string | null
    image?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_term?: string | null
    utm_content?: string | null
    rewrite?: boolean
    ios?: string | null
    android?: string | null
    userId?: string | null
    projectId?: string | null
    clicks?: number
    publicStats?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLinksNestedInput
    project?: ProjectUpdateOneWithoutLinksNestedInput
    projectDomain?: DomainUpdateOneWithoutLinksNestedInput
  }

  export type LinkUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    proxy?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    rewrite?: BoolFieldUpdateOperationsInput | boolean
    ios?: NullableStringFieldUpdateOperationsInput | string | null
    android?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    publicStats?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}